
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for index.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="prettify.css" />
    <link rel="stylesheet" href="base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="index.html">All files</a> index.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">32.03% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>148/462</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">23.92% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>123/514</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">50% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>23/46</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">100% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>1/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input oninput="onInput()" type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-yes">113x</span></td><td class="text"><pre class="prettyprint lang-js">!function(t,e){"object"==typeof exports&amp;&amp;"object"==typeof module?module.exports=e():<span class="branch-1 cbranch-no" title="branch not covered" >"function"==typeof define&amp;&amp;define.amd?define([],e):"object"==typeof exports?exports.driver=e():t.driver=e()}</span>(global,(()=&gt;(()=&gt;{var t={62:(t,e,a)=&gt;{let l=a(684),s=[3,[{taglbl:0,resol:10,sampletype:7,lblname:"temperature",divide:100},{taglbl:5,resol:100,sampletype:6,lblname:"battery_voltage",divide:1e3}]];t.exports.decodeUplink=function(t){return result=l.watteco_decodeUplink(t,s)}},971:t=&gt;{let e=3,a=4,l=5,s=6,d=7,i=9,r=10,n=12,o={0:0,1:1,2:4};o[e]=4,o[a]=8,o[l]=8,o[s]=16,o[d]=16,o[8]=24,o[i]=24,o[r]=32,o[11]=32,o[n]=32;let u=14,m=16,_=[[{sz:2,lbl:0},{sz:2,lbl:1},{sz:2,lbl:3},{sz:3,lbl:5},{sz:4,lbl:9},{sz:5,lbl:17},{sz:6,lbl:33},{sz:7,lbl:65},{sz:8,lbl:129},{sz:10,lbl:512},{sz:11,lbl:1026},{sz:11,lbl:1027},{sz:11,lbl:1028},{sz:11,lbl:1029},{sz:11,lbl:1030},{sz:11,lbl:1031}],[{sz:7,lbl:111},{sz:5,lbl:26},{sz:4,lbl:12},{sz:3,lbl:3},{sz:3,lbl:7},{sz:2,lbl:2},{sz:2,lbl:0},{sz:3,lbl:2},{sz:6,lbl:54},{sz:9,lbl:443},{sz:9,lbl:441},{sz:10,lbl:885},{sz:10,lbl:884},{sz:10,lbl:880},{sz:11,lbl:1763},{sz:11,lbl:1762}],[{sz:4,lbl:9},{sz:3,lbl:5},{sz:2,lbl:0},{sz:2,lbl:1},{sz:2,lbl:3},{sz:5,lbl:17},{sz:6,lbl:33},{sz:7,lbl:65},{sz:8,lbl:129},{sz:10,lbl:512},{sz:11,lbl:1026},{sz:11,lbl:1027},{sz:11,lbl:1028},{sz:11,lbl:1029},{sz:11,lbl:1030},{sz:11,lbl:1031}]];function p(t,s,p,h){let z=function(){let t=[],e=0;for(;e&lt;m;)t.push({codingType:0,codingTable:0,resolution:null,uncompressSamples:[]}),e+=1;return{batch_counter:0,batch_relative_timestamp:0,series:t}}(),P=function(t){function <span class="fstat-no" title="function not covered" >a(</span>t,e,a){let l=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >a-1;<span class="cstat-no" title="statement not covered" ></span>if(8*t.length&lt;l+a)<span class="cstat-no" title="statement not covered" >throw new Error("Batch : Verify that dest buf is large enough");l</span></span>et d=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;a&gt;0;)<span class="cstat-no" title="statement not covered" >t[l&gt;&gt;3]&amp;1&lt;&lt;(7&amp;l)&amp;&amp;(i|=1&lt;&lt;s-d),a--,d++,l++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>return{i1:0,byteArray:t,getNextSample:function(t,a){let s=a||o[t],r=this.i1;<span class="missing-if-branch" title="if path not taken" >I</span>if(this.i1+=s,t===n&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >32!==s)<span class="cstat-no" title="statement not covered" ></span>throw new Error("Batch : Mauvais sampletype");l</span>et u=0,m=Math.trunc((s-1)/8)+1,_=s%8;for(0===_&amp;&amp;m&gt;0&amp;&amp;(_=8);m&gt;0;){let t=0;for(;_&gt;0;){let e=r&gt;&gt;3;this.byteArray[e]&amp;1&lt;&lt;(7&amp;r)&amp;&amp;(u|=1&lt;&lt;8*(m-1)+t),_--,t++,r+=1}m--,_=8}<span class="missing-if-branch" title="if path not taken" >I</span>if((t==e||t==l||t==d||t==i)&amp;&amp;<span class="branch-4 cbranch-no" title="branch not covered" >u&amp;1&lt;&lt;s-1)<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >s;</span>t&lt;32;t++)<span class="cstat-no" title="statement not covered" >u|=1&lt;&lt;t,s++;r</span></span>eturn u},getNextBifromHi:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >2;</span>e&lt;12;e++){let l=<span class="cstat-no" title="statement not covered" >a(this.byteArray,this.i1,e);<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;_[t].length;a++)<span class="cstat-no" title="statement not covered" >if(_[t][a].sz==e&amp;&amp;l==_[t][a].lbl)<span class="cstat-no" title="statement not covered" >return this.i1+=e,a}<span class="cstat-no" title="statement not covered" ></span></span></span>t</span>hrow new Error("Bi not found in HUFF table")}</span>}}(function(t){var e=[];for(;t.length&gt;=2;)e.push(parseInt(t.substring(0,2),16)),t=t.substring(2,t.length);return e}(p)),E=function(t){let e=t.toString(2);for(;e.length&lt;8;)e="0"+e;return{isCommonTimestamp:parseInt(e[e.length-2],2),hasSample:!parseInt(e[e.length-3],2),batch_req:parseInt(e[e.length-4],2),nb_of_type_measure:parseInt(e.substring(0,4),2)}}(P.getNextSample(a));z.batch_counter=P.getNextSample(a,3),P.getNextSample(a,1);let y=function(t,e,l,s,d){let i=0,r=0;for(let n=0;n&lt;s.nb_of_type_measure;n++){let o={size:d,lbl:e.getNextSample(a,d)},u=b(l,o);<span class="cstat-no" title="statement not covered" >0===n&amp;&amp;(r=u),i=f(e,i),t.series[u]=c(e,l[u].sampletype,o.lbl,i),s.hasSample&amp;&amp;(t.series[u].codingType=e.getNextSample(a,2),t.series[u].codingTable=e.getNextSample(a,2))}<span class="cstat-no" title="statement not covered" ></span>return{last_timestamp:i,i1_of_the_first_sample:r}}</span>(z,P,s,E,t),S=<span class="cstat-no" title="statement not covered" >y.last_timestamp,</span>I=<span class="cstat-no" title="statement not covered" >y.i1_of_the_first_sample;<span class="cstat-no" title="statement not covered" ></span>return E.hasSample&amp;&amp;(S=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,l,s,d,i,n){<span class="cstat-no" title="statement not covered" >return i.isCommonTimestamp?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,l,s,d,i){let n=<span class="cstat-no" title="statement not covered" >e.getNextSample(a,8),</span>o=<span class="cstat-no" title="statement not covered" >{},</span>m=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,l,s){let d=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >e.getNextSample(a,2);<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;l;a++){let l=<span class="cstat-no" title="statement not covered" >e.getNextBifromHi(n);<span class="cstat-no" title="statement not covered" ></span>if(l&lt;=u)<span class="cstat-no" title="statement not covered" >if(0===a)<span class="cstat-no" title="statement not covered" >d.push(t.series[s].uncompressSamples[0].data_relative_timestamp);e</span>lse <span class="cstat-no" title="statement not covered" >if(l&gt;0){let t=<span class="cstat-no" title="statement not covered" >d[a-1];<span class="cstat-no" title="statement not covered" ></span>d.push(e.getNextSample(r,l)+t+Math.pow(2,l)-1)}</span>else <span class="cstat-no" title="statement not covered" >d.push(precedingTimestamp);e</span></span></span>lse <span class="cstat-no" title="statement not covered" >d.push(e.getNextSample(r));<span class="cstat-no" title="statement not covered" >i</span></span>=d[a]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{timestampCommon:d,lastTimestamp:i}}</span>(t,e,n,l),</span>_=<span class="cstat-no" title="statement not covered" >m.timestampCommon,</span>p=<span class="cstat-no" title="statement not covered" >m.lastTimestamp;<span class="cstat-no" title="statement not covered" ></span>for(let l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;d.nb_of_type_measure;l++){let l=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>o.lbl=e.getNextSample(a,i);l</span>et d=<span class="cstat-no" title="statement not covered" >b(s,o);<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;n;i++){<span class="cstat-no" title="statement not covered" >if(e.getNextSample(a,1)){let a=<span class="cstat-no" title="statement not covered" >e.getNextBifromHi(t.series[d].codingTable),</span>r=<span class="cstat-no" title="statement not covered" >{data_relative_timestamp:0,data:{}};<span class="cstat-no" title="statement not covered" ></span>if(a&lt;=u){let i=<span class="cstat-no" title="statement not covered" >t.series[d].uncompressSamples[t.series[d].uncompressSamples.length-1].data.value;<span class="cstat-no" title="statement not covered" ></span>if(a&gt;0)<span class="cstat-no" title="statement not covered" >r.data.value=v(e,i,t.series[d].codingType,s[d].resol,a);e</span>lse{<span class="cstat-no" title="statement not covered" >if(l){<span class="cstat-no" title="statement not covered" >l=0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>r</span>.data.value=i}</span>}</span>else <span class="cstat-no" title="statement not covered" >r.data.value=e.getNextSample(s[d].sampletype);<span class="cstat-no" title="statement not covered" >r</span></span>.data_relative_timestamp=_[i],t.series[d].uncompressSamples.push(r)}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn p}</span>(t,e,l,s,i,n):<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,l,s,d,i){let r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;d.nb_of_type_measure;n++){<span class="cstat-no" title="statement not covered" >r.lbl=e.getNextSample(a,i);l</span>et d=<span class="cstat-no" title="statement not covered" >b(l,r),</span>n=<span class="cstat-no" title="statement not covered" >e.getNextSample(a,8);<span class="cstat-no" title="statement not covered" ></span>if(n){let i=<span class="cstat-no" title="statement not covered" >e.getNextSample(a,2);<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;n;a++){let a=<span class="cstat-no" title="statement not covered" >t.series[d].uncompressSamples[t.series[d].uncompressSamples.length-1].data_relative_timestamp,</span>r=<span class="cstat-no" title="statement not covered" >{data_relative_timestamp:0,data:{}},</span>n=<span class="cstat-no" title="statement not covered" >e.getNextBifromHi(i);<span class="cstat-no" title="statement not covered" ></span>if(r.data_relative_timestamp=g(e,a,n),r.data_relative_timestamp&gt;s&amp;&amp;(s=r.data_relative_timestamp),n=e.getNextBifromHi(t.series[d].codingTable),n&lt;=u){let a=<span class="cstat-no" title="statement not covered" >t.series[d].uncompressSamples[t.series[d].uncompressSamples.length-1].data.value;<span class="cstat-no" title="statement not covered" ></span>r.data.value=n&gt;0?v(e,a,t.series[d].codingType,l[d].resol,n):a}</span>else <span class="cstat-no" title="statement not covered" >r.data.value=e.getNextSample(l[d].sampletype);<span class="cstat-no" title="statement not covered" >t</span></span>.series[d].uncompressSamples.push(r)}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>(t,e,s,d,i,n)}</span>(z,P,I,s,S,E,t)),z.batch_relative_timestamp=f(P,S),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,a){let l=<span class="cstat-no" title="statement not covered" >{batch_counter:t.batch_counter,batch_relative_timestamp:t.batch_relative_timestamp};<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;(l.batch_absolute_timestamp=a);<span class="cstat-no" title="statement not covered" >r</span>eturn l.dataset=t.series.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(l,s,d){<span class="cstat-no" title="statement not covered" >return l.concat(s.uncompressSamples.map((<span class="fstat-no" title="function not covered" >fu</span>nction(l){let s=<span class="cstat-no" title="statement not covered" >{data_relative_timestamp:l.data_relative_timestamp,data:{value:e[d].divide?l.data.value/e[d].divide:l.data.value,label:e[d].taglbl}};</span>var i,r,n;<span class="cstat-no" title="statement not covered" >return e[d].lblname&amp;&amp;(s.data.label_name=e[d].lblname),a&amp;&amp;(s.data_absolute_timestamp=(i=a,r=t.batch_relative_timestamp,n=l.data_relative_timestamp,new Date(new Date(i)-1e3*(r-n)).toISOString())),s}</span>)))}</span>),[]),l}</span>(z,s,h)}</span>function <span class="fstat-no" title="function not covered" >c(</span>t,e,a,l){<span class="cstat-no" title="statement not covered" >return{uncompressSamples:[{data_relative_timestamp:l,data:{value:h(t,e),label:a}}],codingType:0,codingTable:0,resolution:null}}</span>function b(t,e){for(let a=0;a&lt;t.length;a++)<span class="missing-if-branch" title="if path not taken" >I</span>if(t[a].taglbl===e.lbl)<span class="cstat-no" title="statement not covered" >return a;t</span>hrow new Error("Batch : Cannot find i1 in argList")}function <span class="fstat-no" title="function not covered" >f(</span>t,e){<span class="cstat-no" title="statement not covered" >if(e){let a=<span class="cstat-no" title="statement not covered" >t.getNextBifromHi(1);<span class="cstat-no" title="statement not covered" ></span>return g(t,e,a)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.getNextSample(r)}</span>function <span class="fstat-no" title="function not covered" >g(</span>t,e,a){<span class="cstat-no" title="statement not covered" >return a&gt;u?t.getNextSample(r):a&gt;0?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,a){<span class="cstat-no" title="statement not covered" >return t.getNextSample(r,a)+e+Math.pow(2,a)-1}</span>(t,e,a):e}</span>function <span class="fstat-no" title="function not covered" >h(</span>t,e){let a=<span class="cstat-no" title="statement not covered" >t.getNextSample(e);<span class="cstat-no" title="statement not covered" ></span>return e===n?<span class="fstat-no" title="function not covered" >fu</span>nction(t){let e=<span class="cstat-no" title="statement not covered" >2147483648&amp;t?-1:1,</span>a=<span class="cstat-no" title="statement not covered" >(t&gt;&gt;23&amp;255)-127,</span>l=<span class="cstat-no" title="statement not covered" >8388607&amp;t;<span class="cstat-no" title="statement not covered" ></span>if(128===a)<span class="cstat-no" title="statement not covered" >return e*(l?Number.NaN:Number.POSITIVE_INFINITY);<span class="cstat-no" title="statement not covered" >i</span></span>f(-127===a){<span class="cstat-no" title="statement not covered" >if(0===l)<span class="cstat-no" title="statement not covered" >return 0*e;<span class="cstat-no" title="statement not covered" >a</span></span>=-126,l/=1&lt;&lt;22}</span>else <span class="cstat-no" title="statement not covered" >l=(l|1&lt;&lt;23)/(1&lt;&lt;23);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e*l*Math.pow(2,a)}</span>(a):a}</span>function <span class="fstat-no" title="function not covered" >v(</span>t,e,a,l,d){let i=<span class="cstat-no" title="statement not covered" >t.getNextSample(s,d);<span class="cstat-no" title="statement not covered" ></span>return 0===a?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,a,l){<span class="cstat-no" title="statement not covered" >return t&gt;=Math.pow(2,l-1)?t*e+a:(t+1-Math.pow(2,l))*e+a}</span>(i,l,e,d):1===a?(i+Math.pow(2,d)-1)*l+e:e-(i+(Math.pow(2,d)-1))*l}</span>Math.trunc=Math.trunc||<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return isNaN(t)?NaN:t&gt;0?Math.floor(t):Math.ceil(t)}</span>,</span>t.exports={normalisation_batch:function(t){let e=t.date,a=p(t.batch1,t.batch2,t.payload,e);<span class="cstat-no" title="statement not covered" >console.log(a);l</span>et l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;a.dataset.length;t++){let e=<span class="cstat-no" title="statement not covered" >a.dataset[t],</span>s=<span class="cstat-no" title="statement not covered" >{variable:e.data.label_name,value:e.data.value,date:e.data_absolute_timestamp};<span class="cstat-no" title="statement not covered" ></span>l.push(s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn l}</span>}},684:(t,e,a)=&gt;{const l=a(263),s=a(971);t.exports={watteco_decodeUplink:function(t,e,a){t.bytes,t.fPort;let d=t.recvTime;try{let i=l.normalisation_standard(t,a),r=i.payload;if("batch"!==i.type)return{data:i.data,warnings:[i.warning]};{let t={batch1:e[0],batch2:e[1],payload:r,date:d};try{return{data:s.normalisation_batch(t),warnings:[""]}}catch(t){return{error:t.message,warnings:[""]}}}}catch(t){<span class="cstat-no" title="statement not covered" >return{error:t.message,warnings:[""]}}</span>}}},263:t=&gt;{function e(t,e){return 2===e&amp;&amp;(32768&amp;t)&gt;0&amp;&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >t-=65536)</span>,3===e&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >(8388608&amp;t)&gt;0&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >t-=16777216)</span>,4===e&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >(2147483648&amp;t)&gt;0&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >t-=4294967296)</span>,t}function <span class="fstat-no" title="function not covered" >a(</span>t){let e=<span class="cstat-no" title="statement not covered" >2147483648&amp;t?-1:1,</span>a=<span class="cstat-no" title="statement not covered" >(t&gt;&gt;23&amp;255)-127,</span>l=<span class="cstat-no" title="statement not covered" >8388607&amp;t;<span class="cstat-no" title="statement not covered" ></span>if(128===a)<span class="cstat-no" title="statement not covered" >return e*(l?Number.NaN:Number.POSITIVE_INFINITY);<span class="cstat-no" title="statement not covered" >i</span></span>f(-127===a){<span class="cstat-no" title="statement not covered" >if(0===l)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >a</span></span>=-126,l/=1&lt;&lt;23}</span>else <span class="cstat-no" title="statement not covered" >l=(l|1&lt;&lt;23)/(1&lt;&lt;23);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e*l*Math.pow(2,a)}</span>function <span class="fstat-no" title="function not covered" >l(</span>t,e,a,l){<span class="cstat-no" title="statement not covered" >void 0===l&amp;&amp;(l=!1);l</span>et s,d,i=<span class="cstat-no" title="statement not covered" >"U"!=a.substr(0,1),</span>r=<span class="cstat-no" title="statement not covered" >parseInt(a.substr(1,2),10)/8,</span>n=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>for(l?(s=-1,d=e+r-1):s=1,d=e,tmpInt64=0,j=d;n&gt;0;j+=s,n--)<span class="cstat-no" title="statement not covered" >tmpInt64=(tmpInt64&lt;&lt;8)+t[j];<span class="cstat-no" title="statement not covered" >r</span></span>eturn i&amp;&amp;r&lt;8&amp;&amp;128&amp;t[d]&amp;&amp;(tmpInt64-=1&lt;&lt;8*r),tmpInt64}</span>function s(t,e){let a=t.toString(16).toUpperCase();for(e=null==e?<span class="branch-0 cbranch-no" title="branch not covered" >e=2:</span>e;a.length&lt;e;)a="0"+a;return"0x"+a}function <span class="fstat-no" title="function not covered" >d(</span>t){var e,a=<span class="cstat-no" title="statement not covered" >"",</span>l=<span class="cstat-no" title="statement not covered" >t.toString(2);<span class="cstat-no" title="statement not covered" ></span>return a+=(e=8,String(l).padStart(e,"0"))}</span>function <span class="fstat-no" title="function not covered" >i(</span>t,e,a,l,s,i){let r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;0===a;){let n=<span class="cstat-no" title="statement not covered" >l[i+3+t*r];<span class="cstat-no" title="statement not covered" ></span>if(void 0===n){<span class="cstat-no" title="statement not covered" >console.log(e),s.zclheader.alarmmess=e,a=1;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>l</span>et o=<span class="cstat-no" title="statement not covered" >d(n);<span class="cstat-no" title="statement not covered" ></span>if("1"===o[3]&amp;&amp;"0"===o[4]){let t=<span class="cstat-no" title="statement not covered" >"threshold",</span>a=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>a="1"===o[1]?"exceed":"fall";l</span>et l=<span class="cstat-no" title="statement not covered" >a+" "+t+" detected";<span class="cstat-no" title="statement not covered" ></span>e.push(l)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("0"===o[3]&amp;&amp;"1"===o[4]){let t=<span class="cstat-no" title="statement not covered" >"delta triggered";<span class="cstat-no" title="statement not covered" ></span>e.push(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>+=1}</span>}</span>function <span class="fstat-no" title="function not covered" >r(</span>t,e,a,l,s,i,r){let n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >t,</span>m=<span class="cstat-no" title="statement not covered" >0,</span>_=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;0===a;){let p=<span class="cstat-no" title="statement not covered" >l[i+3+t*n];<span class="cstat-no" title="statement not covered" ></span>if(void 0===p){<span class="cstat-no" title="statement not covered" >console.log(e),s.zclheader.alarmmess=e,a=1;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>t</span>!==u&amp;&amp;(t=u);l</span>et c=<span class="cstat-no" title="statement not covered" >d(p);<span class="cstat-no" title="statement not covered" ></span>if("1"===c[3]&amp;&amp;"0"===c[4]){<span class="cstat-no" title="statement not covered" >"1"===d(l[i+6+t*n])[0]&amp;&amp;(o=1,t+=2);l</span>et a=<span class="cstat-no" title="statement not covered" >"threshold",</span>s=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>"1"===c[1]?(s="exceed",m=d(l[i+7+t*n])+d(l[i+8+t*n]),m=parseInt(m,2),1===o&amp;&amp;(_=d(l[i+9+t*n])+d(l[i+10+t*n]),_=parseInt(_,2))):(s="fall",1===o?(m=d(l[i+7+t*n])+d(l[i+8+t*n]),m=parseInt(m,2),_=d(l[i+9+t*n])+d(l[i+10+t*n]),_=parseInt(_,2)):(_=d(l[i+7+t*n])+d(l[i+8+t*n]),_=parseInt(_,2)));l</span>et u=<span class="cstat-no" title="statement not covered" >a+" "+s+" detected: value: "+((256*l[i+4+t*n]+l[i+5+t*n])/r).toString()+" countUp: "+m+", countDown: "+_;<span class="cstat-no" title="statement not covered" ></span>e.push(u),1===o&amp;&amp;(t-=2,o=0)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("0"===c[3]&amp;&amp;"1"===c[4]){let a=<span class="cstat-no" title="statement not covered" >"delta triggered : "+((256*l[i+4+(t-=3)*n]+l[i+5+t*n])/r).toString();<span class="cstat-no" title="statement not covered" ></span>e.push(a)}<span class="cstat-no" title="statement not covered" ></span>n</span>+=1}</span>}</span>t.exports={normalisation_standard:function(t,n){let o="",u=t.bytes;console.log(t);let m=function(t,n){let o={lora:{}};o.lora.port=n;let u=t.length,m="";o.lora.payload="";for(let e=0;e&lt;u;e++){m=t[e].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.lora.payload+=m;let a=new Date;o.lora.date=a.toISOString()}<span class="missing-if-branch" title="else path not taken" >E</span>if(125===n)if(!1==!(1&amp;t[0])){o.zclheader={},o.zclheader.report="standard";let n=-1,u=-1,_=-1;if(o.zclheader.endpoint=(224&amp;t[0])&gt;&gt;5|(6&amp;t[0])&lt;&lt;2,u=t[1],o.zclheader.cmdID=s(u,2),_=256*t[2]+t[3],o.zclheader.clustID=s(_,4),10===u|138===u|1===u){o.data={},n=256*t[4]+t[5],o.zclheader.attID=s(n,4);let p=0;if(10!==u&amp;&amp;138!==u||(p=7),138===u&amp;&amp;(o.zclheader.alarm=1),1===u&amp;&amp;(p=8,o.zclheader.status=t[6]),1026===_&amp;&amp;0===n&amp;&amp;(o.data.temperature=e(256*t[p]+t[p+1],2)/100,138===u)){let e="",a=[],l=0,s=100;void 0===t[p+2]?(e="none",console.log("je suis dans le test undefined")):(<span class="branch-1 cbranch-no" title="branch not covered" >e=d(t[p+2]),console.log("je suis dans le test defined"))</span>,"none"===e&amp;&amp;(a.push("alarm triggered"),o.zclheader.alarmmess=a),"0"===e[2]&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >"1"===e[3]&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >i(1,a,l,t,o,p),</span>"1"===e[2]&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >"0"===e[3]&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >r(6,a,l,t,o,p,s)}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(1029===_&amp;&amp;0===n&amp;&amp;(o.data.humidity=(256*t[p]+t[p+1])/100,138===u)){<span class="cstat-no" title="statement not covered" >void 0!==t[p+2]&amp;&amp;d(t[p+2]);l</span>et e=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >100,</span>s=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>void 0===t[p+2]?(s="none",console.log("je suis dans le test undefined")):(s=d(t[p+2]),console.log("je suis dans le test defined")),"none"===s&amp;&amp;(e.push("alarm triggered"),o.zclheader.alarmmess=e),"0"===s[2]&amp;&amp;"1"===s[3]&amp;&amp;i(1,e,a,t,o,p),"1"===s[2]&amp;&amp;"0"===s[3]&amp;&amp;r(6,e,a,t,o,p,l)}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(15===_&amp;&amp;1026===n&amp;&amp;(o.data.counter=256*t[p]*256*256+256*t[p+1]*256+256*t[p+2]+t[p+3]),15===_&amp;&amp;85===n&amp;&amp;(o.data.pin_state=!!t[p]),19===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >85===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.value=t[p])</span>,6===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n)</span>{let e=<span class="cstat-no" title="statement not covered" >t[p];<span class="cstat-no" title="statement not covered" ></span>o.data.state=1===e?"ON":"OFF"}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(32776===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.differential_pressure=256*t[p]+t[p+1])</span>,32773===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.pin_state_1=1==(1&amp;t[p+1]),o.data.pin_state_2=2==(2&amp;t[p+1]),o.data.pin_state_3=4==(4&amp;t[p+1]),o.data.pin_state_4=8==(8&amp;t[p+1]),o.data.pin_state_5=16==(16&amp;t[p+1]),o.data.pin_state_6=32==(32&amp;t[p+1]),o.data.pin_state_7=64==(64&amp;t[p+1]),o.data.pin_state_8=128==(128&amp;t[p+1]),o.data.pin_state_9=1==(1&amp;t[p]),o.data.pin_state_10=2==(2&amp;t[p]))</span>,12===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >85===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.analog=a(256*t[p]*256*256+256*t[p+1]*256+256*t[p+2]+t[p+3]))</span>,32775===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >1===n)</span>{<span class="cstat-no" title="statement not covered" >o.data.payload="",o.data.modbus_payload="",o.data.size=t[p],o.data.modbus_float=0;<span class="cstat-no" title="statement not covered" >f</span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o.data.size;e++)<span class="cstat-no" title="statement not covered" >if(m=t[p+e+1].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.payload+=m,0===e)<span class="cstat-no" title="statement not covered" >o.data.modbus_address=t[p+e+1];e</span>lse <span class="cstat-no" title="statement not covered" >if(1===e)<span class="cstat-no" title="statement not covered" >o.data.modbus_commandID=t[p+e+1];e</span>lse <span class="cstat-no" title="statement not covered" >if(2===e)<span class="cstat-no" title="statement not covered" >o.data.modbus_size=t[p+e+1];e</span>lse{<span class="cstat-no" title="statement not covered" >if(o.data.modbus_payload+=m,1===o.data.modbus_float){let l=<span class="cstat-no" title="statement not covered" >a(256*t[p+e+1]*256*256+256*t[p+e+1+1]*256+256*t[p+e+1+2]+t[p+e+1+3]);<span class="cstat-no" title="statement not covered" ></span>3===e&amp;&amp;(o.data.fregister_00=l),7===e&amp;&amp;(o.data.fregister_01=l),11===e&amp;&amp;(o.data.fregister_02=l),15===e&amp;&amp;(o.data.fregister_03=l),19===e&amp;&amp;(o.data.fregister_04=l),23===e&amp;&amp;(o.data.fregister_05=l),27===e&amp;&amp;(o.data.fregister_06=l),31===e&amp;&amp;(o.data.fregister_07=l),35===e&amp;&amp;(o.data.fregister_08=l),35===e&amp;&amp;(o.data.fregister_09=l)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(2===o.data.modbus_float){let l=<span class="cstat-no" title="statement not covered" >a(256*t[p+e+1]+t[p+e+1+1]+256*t[p+e+1+2]*256*256+256*t[p+e+1+3]*256);<span class="cstat-no" title="statement not covered" ></span>3===e&amp;&amp;(o.data.fregister_00=l),7===e&amp;&amp;(o.data.fregister_01=l),11===e&amp;&amp;(o.data.fregister_02=l),15===e&amp;&amp;(o.data.fregister_03=l),19===e&amp;&amp;(o.data.fregister_04=l),23===e&amp;&amp;(o.data.fregister_05=l),27===e&amp;&amp;(o.data.fregister_06=l),31===e&amp;&amp;(o.data.fregister_07=l),35===e&amp;&amp;(o.data.fregister_08=l),35===e&amp;&amp;(o.data.fregister_09=l)}</span>}</span>}<span class="missing-if-branch" title="if path not taken" >I</span></span></span></span></span>if(32777===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n)</span>{let e=<span class="cstat-no" title="statement not covered" >t[p+2],</span>a=<span class="cstat-no" title="statement not covered" >t[p+3];<span class="cstat-no" title="statement not covered" ></span>o.data.payloads="",o.data.size=t[p],o.data.multimodbus_frame_series_sent=t[p+1],o.data.multimodbus_frame_number_in_serie=(224&amp;e)&gt;&gt;5,o.data.multimodbus_last_frame_of_serie=(28&amp;e)&gt;&gt;2,o.data.multimodbus_EP9=1==(1&amp;e),o.data.multimodbus_EP8=2==(2&amp;e),o.data.multimodbus_EP7=128==(128&amp;a),o.data.multimodbus_EP6=64==(64&amp;a),o.data.multimodbus_EP5=32==(32&amp;a),o.data.multimodbus_EP4=16==(16&amp;a),o.data.multimodbus_EP3=8==(8&amp;a),o.data.multimodbus_EP2=4==(4&amp;a),o.data.multimodbus_EP1=2==(2&amp;a),o.data.multimodbus_EP0=1==(1&amp;a);l</span>et l=<span class="cstat-no" title="statement not covered" >p+4;<span class="cstat-no" title="statement not covered" ></span>if(without_header=0,!0===o.data.multimodbus_EP0){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP0_slaveID=t[l],o.data.multimodbus_EP0_fnctID=t[l+1],o.data.multimodbus_EP0_datasize=t[l+2],l+=3),o.data.multimodbus_EP0_payload="",void 0===t[l])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o.data.multimodbus_EP0_datasize;e++)<span class="cstat-no" title="statement not covered" >m=t[l+e].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP0_payload+=m;<span class="cstat-no" title="statement not covered" >l</span></span>+=o.data.multimodbus_EP0_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP1){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP1_slaveID=t[l],o.data.multimodbus_EP1_fnctID=t[l+1],o.data.multimodbus_EP1_datasize=t[l+2],l+=3),o.data.multimodbus_EP1_payload="",void 0===t[l])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o.data.multimodbus_EP1_datasize;e++)<span class="cstat-no" title="statement not covered" >m=t[l+e].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP1_payload+=m;<span class="cstat-no" title="statement not covered" >l</span></span>+=o.data.multimodbus_EP1_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP2){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP2_slaveID=t[l],o.data.multimodbus_EP2_fnctID=t[l+1],o.data.multimodbus_EP2_datasize=t[l+2],l+=3),o.data.multimodbus_EP2_payload="",void 0===t[l])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o.data.multimodbus_EP2_datasize;e++)<span class="cstat-no" title="statement not covered" >m=t[l+e].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP2_payload+=m;<span class="cstat-no" title="statement not covered" >l</span></span>+=o.data.multimodbus_EP2_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP3){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP3_slaveID=t[l],o.data.multimodbus_EP3_fnctID=t[l+1],o.data.multimodbus_EP3_datasize=t[l+2],l+=3),o.data.multimodbus_EP3_payload="",void 0===t[l])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o.data.multimodbus_EP3_datasize;e++)<span class="cstat-no" title="statement not covered" >m=t[l+e].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP3_payload+=m;<span class="cstat-no" title="statement not covered" >l</span></span>+=o.data.multimodbus_EP3_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP4){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP4_slaveID=t[l],o.data.multimodbus_EP4_fnctID=t[l+1],o.data.multimodbus_EP4_datasize=t[l+2],l+=3),o.data.multimodbus_EP4_payload="",void 0===t[l])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o.data.multimodbus_EP4_datasize;e++)<span class="cstat-no" title="statement not covered" >m=t[l+e].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP4_payload+=m;<span class="cstat-no" title="statement not covered" >l</span></span>+=o.data.multimodbus_EP4_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP5){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP5_slaveID=t[l],o.data.multimodbus_EP5_fnctID=t[l+1],o.data.multimodbus_EP5_datasize=t[l+2],l+=3),o.data.multimodbus_EP5_payload="",void 0===t[l])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o.data.multimodbus_EP5_datasize;e++)<span class="cstat-no" title="statement not covered" >m=t[l+e].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP5_payload+=m;<span class="cstat-no" title="statement not covered" >l</span></span>+=o.data.multimodbus_EP5_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP6){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP6_slaveID=t[l],o.data.multimodbus_EP6_fnctID=t[l+1],o.data.multimodbus_EP6_datasize=t[l+2],l+=3),o.data.multimodbus_EP6_payload="",void 0===t[l])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o.data.multimodbus_EP6_datasize;e++)<span class="cstat-no" title="statement not covered" >m=t[l+e].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP6_payload+=m;<span class="cstat-no" title="statement not covered" >l</span></span>+=o.data.multimodbus_EP6_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP7){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP7_slaveID=t[l],o.data.multimodbus_EP7_fnctID=t[l+1],o.data.multimodbus_EP7_datasize=t[l+2],l+=3),o.data.multimodbus_EP7_payload="",void 0===t[l])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o.data.multimodbus_EP7_datasize;e++)<span class="cstat-no" title="statement not covered" >m=t[l+e].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP7_payload+=m;<span class="cstat-no" title="statement not covered" >l</span></span>+=o.data.multimodbus_EP7_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP8){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP8_slaveID=t[l],o.data.multimodbus_EP8_fnctID=t[l+1],o.data.multimodbus_EP8_datasize=t[l+2],l+=3),o.data.multimodbus_EP8_payload="",void 0===t[l])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o.data.multimodbus_EP8_datasize;e++)<span class="cstat-no" title="statement not covered" >m=t[l+e].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP8_payload+=m;<span class="cstat-no" title="statement not covered" >l</span></span>+=o.data.multimodbus_EP8_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP9){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP6_slaveID=t[l],o.data.multimodbus_EP6_fnctID=t[l+1],o.data.multimodbus_EP6_datasize=t[l+2],l+=3),o.data.multimodbus_EP6_payload="",void 0===t[l])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o.data.multimodbus_EP6_datasize;e++)<span class="cstat-no" title="statement not covered" >m=t[l+e].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP6_payload+=m;<span class="cstat-no" title="statement not covered" >l</span></span>+=o.data.multimodbus_EP6_datasize}</span>}</span>if(82===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.active_energy_Wh=e(256*t[p+1]*256+256*t[p+2]+t[p+3],3),o.data.reactive_energy_Varh=e(256*t[p+4]*256+256*t[p+5]+t[p+6],3),o.data.nb_samples=256*t[p+7]+t[p+8],o.data.active_power_W=e(256*t[p+9]+t[p+10],2),o.data.reactive_power_let=e(256*t[p+11]+t[p+12],2))</span>,32772===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >1===t[p]&amp;&amp;(o.data.message_type="confirmed"),0===t[p]&amp;&amp;(o.data.message_type="unconfirmed"))</span>,32772===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >1===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.nb_retry=t[p])</span>,32772===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >2===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.period_in_minutes=256*t[p+1]+t[p+2],o.data.nb_err_frames=256*t[p+3]+t[p+4])</span>,80===_&amp;&amp;6===n){let e=p+3;<span class="missing-if-branch" title="if path not taken" >I</span>if(1==(1&amp;t[p+2])&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o.data.main_or_external_voltage=(256*t[e]+t[e+1])/1e3,e+=2)</span>,2==(2&amp;t[p+2])&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o.data.rechargeable_battery_voltage=(256*t[e]+t[e+1])/1e3,e+=2)</span>,4==(4&amp;t[p+2])&amp;&amp;(o.data.disposable_battery_voltage=(256*t[e]+t[e+1])/1e3,e+=2),8==(8&amp;t[p+2])&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o.data.solar_harvesting_voltage=(256*t[e]+t[e+1])/1e3,e+=2)</span>,16==(16&amp;t[p+2])&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o.data.tic_harvesting_voltage=(256*t[e]+t[e+1])/1e3,e+=2)</span>,138===u){<span class="cstat-no" title="statement not covered" >void 0!==t[p+2]&amp;&amp;d(t[p+2]);l</span>et e=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >1e3,</span>s=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>void 0===t[p+2]?(s="none",console.log("je suis dans le test undefined")):(s=d(t[p+2]),console.log("je suis dans le test defined")),"none"===s&amp;&amp;(e.push("alarm triggered"),o.zclheader.alarmmess=e),"0"===s[2]&amp;&amp;"1"===s[3]&amp;&amp;i(1,e,a,t,o,p),"1"===s[2]&amp;&amp;"0"===s[3]&amp;&amp;r(6,e,a,t,o,p,l)}</span>}<span class="missing-if-branch" title="if path not taken" >I</span>if(32778===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n)</span>{let a=<span class="cstat-no" title="statement not covered" >p;<span class="cstat-no" title="statement not covered" ></span>o.data.sum_positive_active_energy_Wh=e(256*t[a+1]*256*256+256*t[a+2]*256+256*t[a+3]+t[a+4],4),a+=4,o.data.sum_negative_active_energy_Wh=e(256*t[a+1]*256*256+256*t[a+2]*256+256*t[a+3]+t[a+4],4),a+=4,o.data.sum_positive_reactive_energy_Wh=e(256*t[a+1]*256*256+256*t[a+2]*256+256*t[a+3]+t[a+4],4),a+=4,o.data.sum_negative_reactive_energy_Wh=e(256*t[a+1]*256*256+256*t[a+2]*256+256*t[a+3]+t[a+4],4),a+=4,o.data.positive_active_power_W=e(256*t[a+1]*256*256+256*t[a+2]*256+256*t[a+3]+t[a+4],4),a+=4,o.data.negative_active_power_W=e(256*t[a+1]*256*256+256*t[a+2]*256+256*t[a+3]+t[a+4],4),a+=4,o.data.positive_reactive_power_W=e(256*t[a+1]*256*256+256*t[a+2]*256+256*t[a+3]+t[a+4],4),a+=4,o.data.negative_reactive_power_W=e(256*t[a+1]*256*256+256*t[a+2]*256+256*t[a+3]+t[a+4],4)}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(32784===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n?</span>(<span class="branch-0 cbranch-no" title="branch not covered" >o.data.ActiveEnergyWhPhaseA=Int32UnsignedToSigned(256*t[p+1]*256*256+256*t[p+2]*256+256*t[p+3]+t[p+4]),o.data.ReactiveEnergyWhPhaseA=Int32UnsignedToSigned(256*t[p+5]*256*256+256*t[p+6]*256+256*t[p+7]+t[p+8]),o.data.ActiveEnergyWhPhaseB=Int32UnsignedToSigned(256*t[p+9]*256*256+256*t[p+10]*256+256*t[p+11]+t[p+12]),o.data.ReactiveEnergyWhPhaseB=Int32UnsignedToSigned(256*t[p+13]*256*256+256*t[p+14]*256+256*t[p+15]+t[p+16]),o.data.ActiveEnergyWhPhaseC=Int32UnsignedToSigned(256*t[p+17]*256*256+256*t[p+18]*256+256*t[p+19]+t[p+20]),o.data.ReactiveEnergyWhPhaseC=Int32UnsignedToSigned(256*t[p+21]*256*256+256*t[p+22]*256+256*t[p+23]+t[p+24]),o.data.ActiveEnergyWhPhaseABC=Int32UnsignedToSigned(256*t[p+25]*256*256+256*t[p+26]*256+256*t[p+27]+t[p+28]),o.data.ReactiveEnergyWhPhaseABC=Int32UnsignedToSigned(256*t[p+29]*256*256+256*t[p+30]*256+256*t[p+31]+t[p+32]))</span>:32784===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >1===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.ActivePowerWPhaseA=Int32UnsignedToSigned(256*t[p+1]*256*256+256*t[p+2]*256+256*t[p+3]+t[p+4]),o.data.ReactivePowerWPhaseA=Int32UnsignedToSigned(256*t[p+5]*256*256+256*t[p+6]*256+256*t[p+7]+t[p+8]),o.data.ActivePowerWPhaseB=Int32UnsignedToSigned(256*t[p+9]*256*256+256*t[p+10]*256+256*t[p+11]+t[p+12]),o.data.ReactivePowerWPhaseB=Int32UnsignedToSigned(256*t[p+13]*256*256+256*t[p+14]*256+256*t[p+15]+t[p+16]),o.data.ActivePowerWPhaseC=Int32UnsignedToSigned(256*t[p+17]*256*256+256*t[p+18]*256+256*t[p+19]+t[p+20]),o.data.ReactivePowerWPhaseC=Int32UnsignedToSigned(256*t[p+21]*256*256+256*t[p+22]*256+256*t[p+23]+t[p+24]),o.data.ActivePowerWPhaseABC=Int32UnsignedToSigned(256*t[p+25]*256*256+256*t[p+26]*256+256*t[p+27]+t[p+28]),o.data.ReactivePowerWPhaseABC=Int32UnsignedToSigned(256*t[p+29]*256*256+256*t[p+30]*256+256*t[p+31]+t[p+32]))</span>,32779===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n)</span>{let a=<span class="cstat-no" title="statement not covered" >p;<span class="cstat-no" title="statement not covered" ></span>o.data.Vrms=e(256*t[a+1]+t[a+2],2)/10,a+=2,o.data.Irms=e(256*t[a+1]+t[a+2],2)/10,a+=2,o.data.phase_angle=e(256*t[a+1]+t[a+2],2)}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(32781===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.VrmsA=e(256*t[p+1]+t[p+2],2)/10,o.data.IrmsA=e(256*t[p+3]+t[p+4],2)/10,o.data.PhaseA=e(256*t[p+5]+t[p+6],2),o.data.VrmsB=e(256*t[p+7]+t[p+8],2)/10,o.data.IrmsB=e(256*t[p+9]+t[p+10],2)/10,o.data.PhaseB=e(256*t[p+11]+t[p+12],2),o.data.VrmsC=e(256*t[p+13]+t[p+14],2)/10,o.data.IrmsC=e(256*t[p+15]+t[p+16],2)/10,o.data.PhaseC=e(256*t[p+17]+t[p+18],2))</span>,32780===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.Concentration=256*t[p]+t[p+1])</span>,1024===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.Illuminance=256*t[p]+t[p+1])</span>,1027===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.Pressure=e(256*t[p]+t[p+1],2))</span>,1030===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.Occupancy=!!t[p])</span>,32850===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n)</span>{let a=<span class="cstat-no" title="statement not covered" >p;<span class="cstat-no" title="statement not covered" ></span>o.data.frequency=(e(256*t[a+1]+t[a+2],2)+22232)/1e3,a+=2,o.data.frequency_min=(e(256*t[a+1]+t[a+2],2)+22232)/1e3,a+=2,o.data.frequency_max=(e(256*t[a+1]+t[a+2],2)+22232)/1e3,a+=2,o.data.Vrms=e(256*t[a+1]+t[a+2],2)/10,a+=2,o.data.Vrms_min=e(256*t[a+1]+t[a+2],2)/10,a+=2,o.data.Vrms_max=e(256*t[a+1]+t[a+2],2)/10,a+=2,o.data.Vpeak=e(256*t[a+1]+t[a+2],2)/10,a+=2,o.data.Vpeak_min=e(256*t[a+1]+t[a+2],2)/10,a+=2,o.data.Vpeak_max=e(256*t[a+1]+t[a+2],2)/10,a+=2,o.data.over_voltage=e(256*t[a+1]+t[a+2],2),a+=2,o.data.sag_voltage=e(256*t[a+1]+t[a+2],2)}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(32783===_){let e=<span class="cstat-no" title="statement not covered" >p+1;<span class="cstat-no" title="statement not covered" ></span>if(0===n){let a=<span class="cstat-no" title="statement not covered" >o.data.Last={};<span class="cstat-no" title="statement not covered" ></span>a.NbTriggedAcq=l(t,e,"U32"),e+=4,a.Mean_X_G=l(t,e,"U16")/100,e+=2,a.Max_X_G=l(t,e,"U16")/100,e+=2,a.Dt_X_ms=l(t,e,"U16"),e+=2,a.Mean_Y_G=l(t,e,"U16")/100,e+=2,a.Max_Y_G=l(t,e,"U16")/100,e+=2,a.Dt_Y_ms=l(t,e,"U16"),e+=2,a.Mean_Z_G=l(t,e,"U16")/100,e+=2,a.Max_Z_G=l(t,e,"U16")/100,e+=2,a.Dt_Z_ms=l(t,e,"U16")}</span>else <span class="cstat-no" title="statement not covered" >if(1===n||2===n||3===n){let a=<span class="cstat-no" title="statement not covered" >1===n?"Stats_X":2===n?"Stats_Y":"Stats_Z",</span>s=<span class="cstat-no" title="statement not covered" >o.data[a]={};<span class="cstat-no" title="statement not covered" ></span>s.NbAcq=l(t,e,"U16"),e+=2,s.MinMean_G=l(t,e,"U16")/100,e+=2,s.MinMax_G=l(t,e,"U16")/100,e+=2,s.MinDt=l(t,e,"U16"),e+=2,s.MeanMean_G=l(t,e,"U16")/100,e+=2,s.MeanMax_G=l(t,e,"U16")/100,e+=2,s.MeanDt=l(t,e,"U16"),e+=2,s.MaxMean_G=l(t,e,"U16")/100,e+=2,s.MaxMax_G=l(t,e,"U16")/100,e+=2,s.MaxDt=l(t,e,"U16"),e+=2}</span>else <span class="cstat-no" title="statement not covered" >if(32768===n){let a=<span class="cstat-no" title="statement not covered" >o.data.Params={};<span class="cstat-no" title="statement not covered" ></span>a.WaitFreq_Hz=l(t,e,"U16")/10,e+=2,a.AcqFreq_Hz=l(t,e,"U16")/10,e+=2;l</span>et s=<span class="cstat-no" title="statement not covered" >l(t,e,"U16");<span class="cstat-no" title="statement not covered" ></span>e+=2,32768&amp;s&amp;&amp;(s=60*(-32769&amp;s)),a.NewWaitDelay_s=32768&amp;s?s=60*(-32769&amp;s):s,a.MaxAcqDuration_ms=l(t,e,"U16"),e+=2,a.Threshold_X_G=l(t,e,"U16")/100,e+=2,a.Threshold_Y_G=l(t,e,"U16")/100,e+=2,a.Threshold_Z_G=l(t,e,"U16")/100,e+=2,a.OverThrsh_Dt_ms=l(t,e,"U16"),e+=2,a.UnderThrsh_Dt_ms=l(t,e,"U16"),e+=2,a.Range_G=l(t,e,"U16")/100,e+=2,a.FilterSmoothCoef=l(t,e,"U8"),e+=1,a.FilterGainCoef=l(t,e,"U8"),e+=1,a=o.data.Params.WorkingModes={},a.SignalEachAcq=128&amp;t[e]?"true":"false",a.RstAftStdRpt_X=1&amp;t[e]?"true":"false",a.RstAftStdRpt_Y=2&amp;t[e]?"true":"false",a.RstAftStdRpt_7=4&amp;t[e]?"true":"false"}</span>}</span></span></span>}7===u&amp;&amp;(n=256*t[6]+t[7],o.zclheader.attID=s(n,4),o.zclheader.status=t[4],o.zclheader.batch=t[5]),9===u&amp;&amp;(n=256*t[6]+t[7],o.zclheader.attID=s(n,4),o.zclheader.status=t[4],o.zclheader.batch=t[5],o.zclheader.attribut_type=t[8],o.zclheader.min={},128==(128&amp;t[9])?(<span class="branch-0 cbranch-no" title="branch not covered" >o.zclheader.min.value=256*(t[9]-128)+t[10],o.zclheader.min.unity="minutes")</span>:(o.zclheader.min.value=256*t[9]+t[10],o.zclheader.min.unity="seconds"),o.zclheader.max={},128==(128&amp;t[11])?(<span class="branch-0 cbranch-no" title="branch not covered" >o.zclheader.max.value=256*(t[11]-128)+t[12],o.zclheader.max.unity="minutes")</span>:(o.zclheader.max.value=256*t[11]+t[12],o.zclheader.max.unity="seconds"),o.lora.payload="")}else o.batch={},o.batch.report="batch";return o}(u,t.fPort);if(console.log(m),void 0!==m.zclheader&amp;&amp;m.zclheader.alarm&amp;&amp;(o=m.zclheader.alarmmess,console.log(o)),7===u[1]&amp;&amp;u[0]%2!=0)return{data:{variable:"configure reporting response status",value:m.zclheader.status,date:t.recvTime},warning:o};if(9===u[1])return{data:{variable:"read reporting configuration response status",value:m.zclheader.status,date:t.recvTime},warning:o};if(1===u[1])return void 0===m.zclheader.data?{data:{variable:"read reporting configuration response status",value:"no data",date:t.recvTime},warning:o}:<span class="branch-1 cbranch-no" title="branch not covered" >{data:{variable:"read reporting configuration response status",value:m.zclheader.data,date:t.recvTime},warning:o};</span>if(void 0!==m.zclheader){<span class="missing-if-branch" title="if path not taken" >I</span>if(void 0!==n){let e=<span class="cstat-no" title="statement not covered" >m.zclheader.endpoint,</span>a=<span class="cstat-no" title="statement not covered" >Object.keys(m.data)[0];<span class="cstat-no" title="statement not covered" ></span>return{data:{variable:n[a][e],value:m.data[a],date:t.recvTime},type:"standard",warning:o}}</span>{let e=Object.keys(m.data)[0];return{data:{variable:e,value:m.data[e],date:t.recvTime},type:"standard",warning:o}}}return{type:m.batch.report,payload:m.lora.payload}}}}},e={};function a(l){var s=e[l];if(void 0!==s)return s.exports;var d=e[l]={exports:{}};return t[l](d,d.exports,a),d.exports}return a(263),a(971),a(684),a(62)})()));</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2023-08-04T08:31:46.515Z
            </div>
        <script src="prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="sorter.js"></script>
        <script src="block-navigation.js"></script>
    </body>
</html>
    