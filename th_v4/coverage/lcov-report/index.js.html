
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for index.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="prettify.css" />
    <link rel="stylesheet" href="base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="index.html">All files</a> index.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">44.44% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>196/441</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">30.86% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>154/499</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">71.73% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>33/46</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">100% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>1/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input oninput="onInput()" type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-yes">212x</span></td><td class="text"><pre class="prettyprint lang-js">!function(t,a){"object"==typeof exports&amp;&amp;"object"==typeof module?module.exports=a():<span class="branch-1 cbranch-no" title="branch not covered" >"function"==typeof define&amp;&amp;define.amd?define([],a):"object"==typeof exports?exports.driver=a():t.driver=a()}</span>(global,(()=&gt;(()=&gt;{var t={971:t=&gt;{let a=3,e=4,i=5,l=6,s=7,d=9,r=10,n=12,o={0:0,1:1,2:4};o[a]=4,o[e]=8,o[i]=8,o[l]=16,o[s]=16,o[8]=24,o[d]=24,o[r]=32,o[11]=32,o[n]=32;let u=14,m=16,_=[[{sz:2,lbl:0},{sz:2,lbl:1},{sz:2,lbl:3},{sz:3,lbl:5},{sz:4,lbl:9},{sz:5,lbl:17},{sz:6,lbl:33},{sz:7,lbl:65},{sz:8,lbl:129},{sz:10,lbl:512},{sz:11,lbl:1026},{sz:11,lbl:1027},{sz:11,lbl:1028},{sz:11,lbl:1029},{sz:11,lbl:1030},{sz:11,lbl:1031}],[{sz:7,lbl:111},{sz:5,lbl:26},{sz:4,lbl:12},{sz:3,lbl:3},{sz:3,lbl:7},{sz:2,lbl:2},{sz:2,lbl:0},{sz:3,lbl:2},{sz:6,lbl:54},{sz:9,lbl:443},{sz:9,lbl:441},{sz:10,lbl:885},{sz:10,lbl:884},{sz:10,lbl:880},{sz:11,lbl:1763},{sz:11,lbl:1762}],[{sz:4,lbl:9},{sz:3,lbl:5},{sz:2,lbl:0},{sz:2,lbl:1},{sz:2,lbl:3},{sz:5,lbl:17},{sz:6,lbl:33},{sz:7,lbl:65},{sz:8,lbl:129},{sz:10,lbl:512},{sz:11,lbl:1026},{sz:11,lbl:1027},{sz:11,lbl:1028},{sz:11,lbl:1029},{sz:11,lbl:1030},{sz:11,lbl:1031}]];function p(t,l,p,h){let z=function(){let t=[],a=0;for(;a&lt;m;)t.push({codingType:0,codingTable:0,resolution:null,uncompressSamples:[]}),a+=1;return{batch_counter:0,batch_relative_timestamp:0,series:t}}(),P=function(t){function e(t,a,e){let i=a,l=e-1;<span class="missing-if-branch" title="if path not taken" >I</span>if(8*t.length&lt;i+e)<span class="cstat-no" title="statement not covered" >throw new Error("Batch : Verify that dest buf is large enough");l</span>et s=0,d=0;for(;e&gt;0;)t[i&gt;&gt;3]&amp;1&lt;&lt;(7&amp;i)&amp;&amp;(d|=1&lt;&lt;l-s),e--,s++,i++;return d}return{i1:0,byteArray:t,getNextSample:function(t,e){let l=e||o[t],r=this.i1;<span class="missing-if-branch" title="if path not taken" >I</span>if(this.i1+=l,t===n&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >32!==l)<span class="cstat-no" title="statement not covered" ></span>throw new Error("Batch : Mauvais sampletype");l</span>et u=0,m=Math.trunc((l-1)/8)+1,_=l%8;for(0===_&amp;&amp;m&gt;0&amp;&amp;(_=8);m&gt;0;){let t=0;for(;_&gt;0;){let a=r&gt;&gt;3;this.byteArray[a]&amp;1&lt;&lt;(7&amp;r)&amp;&amp;(u|=1&lt;&lt;8*(m-1)+t),_--,t++,r+=1}m--,_=8}<span class="missing-if-branch" title="if path not taken" >I</span>if((t==a||t==i||t==s||t==d)&amp;&amp;u&amp;1&lt;&lt;l-1)<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >l;</span>t&lt;32;t++)<span class="cstat-no" title="statement not covered" >u|=1&lt;&lt;t,l++;r</span></span>eturn u},getNextBifromHi:function(t){for(let a=2;a&lt;12;a++){let i=e(this.byteArray,this.i1,a);for(let e=0;e&lt;_[t].length;e++)if(_[t][e].sz==a&amp;&amp;i==_[t][e].lbl)return this.i1+=a,e}<span class="cstat-no" title="statement not covered" >throw new Error("Bi not found in HUFF table")}</span>}}(function(t){var a=[];for(;t.length&gt;=2;)a.push(parseInt(t.substring(0,2),16)),t=t.substring(2,t.length);return a}(p)),E=function(t){let a=t.toString(2);for(;a.length&lt;8;)a="0"+a;return{isCommonTimestamp:parseInt(a[a.length-2],2),hasSample:!parseInt(a[a.length-3],2),batch_req:parseInt(a[a.length-4],2),nb_of_type_measure:parseInt(a.substring(0,4),2)}}(P.getNextSample(e));z.batch_counter=P.getNextSample(e,3),P.getNextSample(e,1);let y=function(t,a,i,l,s){let d=0,r=0;for(let n=0;n&lt;l.nb_of_type_measure;n++){let o={size:s,lbl:a.getNextSample(e,s)},u=c(i,o);0===n&amp;&amp;(r=u),d=f(a,d),t.series[u]=b(a,i[u].sampletype,o.lbl,d),l.hasSample&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >t.series[u].codingType=a.getNextSample(e,2),t.series[u].codingTable=a.getNextSample(e,2))</span>}return{last_timestamp:d,i1_of_the_first_sample:r}}(z,P,l,E,t),S=y.last_timestamp,I=y.i1_of_the_first_sample;return E.hasSample&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >S=<span class="fstat-no" title="function not covered" >fu</span>nction(t,a,i,l,s,d,n){<span class="cstat-no" title="statement not covered" >return d.isCommonTimestamp?<span class="fstat-no" title="function not covered" >fu</span>nction(t,a,i,l,s,d){let n=<span class="cstat-no" title="statement not covered" >a.getNextSample(e,8),</span>o=<span class="cstat-no" title="statement not covered" >{},</span>m=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,a,i,l){let s=<span class="cstat-no" title="statement not covered" >[],</span>d=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >a.getNextSample(e,2);<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;i;e++){let i=<span class="cstat-no" title="statement not covered" >a.getNextBifromHi(n);<span class="cstat-no" title="statement not covered" ></span>if(i&lt;=u)<span class="cstat-no" title="statement not covered" >if(0===e)<span class="cstat-no" title="statement not covered" >s.push(t.series[l].uncompressSamples[0].data_relative_timestamp);e</span>lse <span class="cstat-no" title="statement not covered" >if(i&gt;0){let t=<span class="cstat-no" title="statement not covered" >s[e-1];<span class="cstat-no" title="statement not covered" ></span>s.push(a.getNextSample(r,i)+t+Math.pow(2,i)-1)}</span>else <span class="cstat-no" title="statement not covered" >s.push(precedingTimestamp);e</span></span></span>lse <span class="cstat-no" title="statement not covered" >s.push(a.getNextSample(r));<span class="cstat-no" title="statement not covered" >d</span></span>=s[e]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{timestampCommon:s,lastTimestamp:d}}</span>(t,a,n,i),</span>_=<span class="cstat-no" title="statement not covered" >m.timestampCommon,</span>p=<span class="cstat-no" title="statement not covered" >m.lastTimestamp;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;s.nb_of_type_measure;i++){let i=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>o.lbl=a.getNextSample(e,d);l</span>et s=<span class="cstat-no" title="statement not covered" >c(l,o);<span class="cstat-no" title="statement not covered" ></span>for(let d=<span class="cstat-no" title="statement not covered" >0;</span>d&lt;n;d++){<span class="cstat-no" title="statement not covered" >if(a.getNextSample(e,1)){let e=<span class="cstat-no" title="statement not covered" >a.getNextBifromHi(t.series[s].codingTable),</span>r=<span class="cstat-no" title="statement not covered" >{data_relative_timestamp:0,data:{}};<span class="cstat-no" title="statement not covered" ></span>if(e&lt;=u){let d=<span class="cstat-no" title="statement not covered" >t.series[s].uncompressSamples[t.series[s].uncompressSamples.length-1].data.value;<span class="cstat-no" title="statement not covered" ></span>if(e&gt;0)<span class="cstat-no" title="statement not covered" >r.data.value=v(a,d,t.series[s].codingType,l[s].resol,e);e</span>lse{<span class="cstat-no" title="statement not covered" >if(i){<span class="cstat-no" title="statement not covered" >i=0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>r</span>.data.value=d}</span>}</span>else <span class="cstat-no" title="statement not covered" >r.data.value=a.getNextSample(l[s].sampletype);<span class="cstat-no" title="statement not covered" >r</span></span>.data_relative_timestamp=_[d],t.series[s].uncompressSamples.push(r)}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn p}</span>(t,a,i,l,d,n):<span class="fstat-no" title="function not covered" >fu</span>nction(t,a,i,l,s,d){let r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;s.nb_of_type_measure;n++){<span class="cstat-no" title="statement not covered" >r.lbl=a.getNextSample(e,d);l</span>et s=<span class="cstat-no" title="statement not covered" >c(i,r),</span>n=<span class="cstat-no" title="statement not covered" >a.getNextSample(e,8);<span class="cstat-no" title="statement not covered" ></span>if(n){let d=<span class="cstat-no" title="statement not covered" >a.getNextSample(e,2);<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;n;e++){let e=<span class="cstat-no" title="statement not covered" >t.series[s].uncompressSamples[t.series[s].uncompressSamples.length-1].data_relative_timestamp,</span>r=<span class="cstat-no" title="statement not covered" >{data_relative_timestamp:0,data:{}},</span>n=<span class="cstat-no" title="statement not covered" >a.getNextBifromHi(d);<span class="cstat-no" title="statement not covered" ></span>if(r.data_relative_timestamp=g(a,e,n),r.data_relative_timestamp&gt;l&amp;&amp;(l=r.data_relative_timestamp),n=a.getNextBifromHi(t.series[s].codingTable),n&lt;=u){let e=<span class="cstat-no" title="statement not covered" >t.series[s].uncompressSamples[t.series[s].uncompressSamples.length-1].data.value;<span class="cstat-no" title="statement not covered" ></span>r.data.value=n&gt;0?v(a,e,t.series[s].codingType,i[s].resol,n):e}</span>else <span class="cstat-no" title="statement not covered" >r.data.value=a.getNextSample(i[s].sampletype);<span class="cstat-no" title="statement not covered" >t</span></span>.series[s].uncompressSamples.push(r)}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn l}</span>(t,a,l,s,d,n)}</span>(z,P,I,l,S,E,t))</span>,z.batch_relative_timestamp=f(P,S),function(t,a,e){let i={batch_counter:t.batch_counter,batch_relative_timestamp:t.batch_relative_timestamp};e&amp;&amp;(i.batch_absolute_timestamp=e);return i.dataset=t.series.reduce((function(i,l,s){return i.concat(l.uncompressSamples.map((function(i){let l={data_relative_timestamp:i.data_relative_timestamp,data:{value:a[s].divide?i.data.value/a[s].divide:<span class="branch-1 cbranch-no" title="branch not covered" >i.data.value,</span>label:a[s].taglbl}};var d,r,n;return a[s].lblname&amp;&amp;(l.data.label_name=a[s].lblname),e&amp;&amp;(l.data_absolute_timestamp=(d=e,r=t.batch_relative_timestamp,n=i.data_relative_timestamp,new Date(new Date(d)-1e3*(r-n)).toISOString())),l})))}),[]),i}(z,l,h)}function b(t,a,e,i){return{uncompressSamples:[{data_relative_timestamp:i,data:{value:h(t,a),label:e}}],codingType:0,codingTable:0,resolution:null}}function c(t,a){for(let e=0;e&lt;t.length;e++)if(t[e].taglbl===a.lbl)return e;<span class="cstat-no" title="statement not covered" >throw new Error("Batch : Cannot find i1 in argList")}</span>function f(t,a){if(a){let e=t.getNextBifromHi(1);return g(t,a,e)}return t.getNextSample(r)}function g(t,a,e){return e&gt;u?<span class="branch-0 cbranch-no" title="branch not covered" >t.getNextSample(r):</span>e&gt;0?function(t,a,e){return t.getNextSample(r,e)+a+Math.pow(2,e)-1}(t,a,e):a}function h(t,a){let e=t.getNextSample(a);return a===n?<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >fu</span>nction(t){let a=<span class="cstat-no" title="statement not covered" >2147483648&amp;t?-1:1,</span>e=<span class="cstat-no" title="statement not covered" >(t&gt;&gt;23&amp;255)-127,</span>i=<span class="cstat-no" title="statement not covered" >8388607&amp;t;<span class="cstat-no" title="statement not covered" ></span>if(128===e)<span class="cstat-no" title="statement not covered" >return a*(i?Number.NaN:Number.POSITIVE_INFINITY);<span class="cstat-no" title="statement not covered" >i</span></span>f(-127===e){<span class="cstat-no" title="statement not covered" >if(0===i)<span class="cstat-no" title="statement not covered" >return 0*a;<span class="cstat-no" title="statement not covered" >e</span></span>=-126,i/=1&lt;&lt;22}</span>else <span class="cstat-no" title="statement not covered" >i=(i|1&lt;&lt;23)/(1&lt;&lt;23);<span class="cstat-no" title="statement not covered" >r</span></span>eturn a*i*Math.pow(2,e)}</span>(e):</span>e}function <span class="fstat-no" title="function not covered" >v(</span>t,a,e,i,s){let d=<span class="cstat-no" title="statement not covered" >t.getNextSample(l,s);<span class="cstat-no" title="statement not covered" ></span>return 0===e?<span class="fstat-no" title="function not covered" >fu</span>nction(t,a,e,i){<span class="cstat-no" title="statement not covered" >return t&gt;=Math.pow(2,i-1)?t*a+e:(t+1-Math.pow(2,i))*a+e}</span>(d,i,a,s):1===e?(d+Math.pow(2,s)-1)*i+a:a-(d+(Math.pow(2,s)-1))*i}</span>Math.trunc=Math.trunc||<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return isNaN(t)?NaN:t&gt;0?Math.floor(t):Math.ceil(t)}</span>,</span>t.exports={normalisation_batch:function(t){let a=t.date,e=p(t.batch1,t.batch2,t.payload,a);console.log(e);let i=[];for(let t=0;t&lt;e.dataset.length;t++){let a=e.dataset[t],l={variable:a.data.label_name,value:a.data.value,date:a.data_absolute_timestamp};i.push(l)}return i}}},421:(t,a,e)=&gt;{let i=e(684),l=[2,[{taglbl:0,resol:10,sampletype:7,lblname:"temperature",divide:100},{taglbl:1,resol:100,sampletype:6,lblname:"humidity",divide:100},{taglbl:2,resol:1,sampletype:6,lblname:"battery_voltage",divide:1e3},{taglbl:3,resol:1,sampletype:1,lblname:"open_case",divide:1}]];t.exports.decodeUplink=function(t){return result=i.watteco_decodeUplink(t,l)}},684:(t,a,e)=&gt;{const i=e(263),l=e(971);t.exports={watteco_decodeUplink:function(t,a,e){t.bytes,t.fPort;let s=t.recvTime;try{let d=i.normalisation_standard(t,e),r=d.payload;if("batch"!==d.type)return{data:d.data,warnings:[d.warning]};{let t={batch1:a[0],batch2:a[1],payload:r,date:s};try{return{data:l.normalisation_batch(t),warnings:[""]}}catch(t){<span class="cstat-no" title="statement not covered" >return{error:t.message,warnings:[""]}}</span>}}catch(t){<span class="cstat-no" title="statement not covered" >return{error:t.message,warnings:[""]}}</span>}}},263:t=&gt;{function a(t,a){return 2===a&amp;&amp;(32768&amp;t)&gt;0&amp;&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >t-=65536)</span>,3===a&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >(8388608&amp;t)&gt;0&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >t-=16777216)</span>,4===a&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >(2147483648&amp;t)&gt;0&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >t-=4294967296)</span>,t}function <span class="fstat-no" title="function not covered" >e(</span>t){let a=<span class="cstat-no" title="statement not covered" >2147483648&amp;t?-1:1,</span>e=<span class="cstat-no" title="statement not covered" >(t&gt;&gt;23&amp;255)-127,</span>i=<span class="cstat-no" title="statement not covered" >8388607&amp;t;<span class="cstat-no" title="statement not covered" ></span>if(128===e)<span class="cstat-no" title="statement not covered" >return a*(i?Number.NaN:Number.POSITIVE_INFINITY);<span class="cstat-no" title="statement not covered" >i</span></span>f(-127===e){<span class="cstat-no" title="statement not covered" >if(0===i)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >e</span></span>=-126,i/=1&lt;&lt;23}</span>else <span class="cstat-no" title="statement not covered" >i=(i|1&lt;&lt;23)/(1&lt;&lt;23);<span class="cstat-no" title="statement not covered" >r</span></span>eturn a*i*Math.pow(2,e)}</span>function <span class="fstat-no" title="function not covered" >i(</span>t,a,e,i){<span class="cstat-no" title="statement not covered" >void 0===i&amp;&amp;(i=!1);l</span>et l,s,d=<span class="cstat-no" title="statement not covered" >"U"!=e.substr(0,1),</span>r=<span class="cstat-no" title="statement not covered" >parseInt(e.substr(1,2),10)/8,</span>n=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>for(i?(l=-1,s=a+r-1):l=1,s=a,tmpInt64=0,j=s;n&gt;0;j+=l,n--)<span class="cstat-no" title="statement not covered" >tmpInt64=(tmpInt64&lt;&lt;8)+t[j];<span class="cstat-no" title="statement not covered" >r</span></span>eturn d&amp;&amp;r&lt;8&amp;&amp;128&amp;t[s]&amp;&amp;(tmpInt64-=1&lt;&lt;8*r),tmpInt64}</span>function l(t,a){let e=t.toString(16).toUpperCase();for(a=null==a?<span class="branch-0 cbranch-no" title="branch not covered" >a=2:</span>a;e.length&lt;a;)e="0"+e;return"0x"+e}function <span class="fstat-no" title="function not covered" >s(</span>t){var a,e=<span class="cstat-no" title="statement not covered" >"",</span>i=<span class="cstat-no" title="statement not covered" >t.toString(2);<span class="cstat-no" title="statement not covered" ></span>return e+=(a=8,String(i).padStart(a,"0"))}</span>function <span class="fstat-no" title="function not covered" >d(</span>t,a,e,i,l,d){let r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;0===e;){let n=<span class="cstat-no" title="statement not covered" >i[d+3+t*r];<span class="cstat-no" title="statement not covered" ></span>if(void 0===n){<span class="cstat-no" title="statement not covered" >console.log(a),l.zclheader.alarmmess=a,e=1;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>l</span>et o=<span class="cstat-no" title="statement not covered" >s(n);<span class="cstat-no" title="statement not covered" ></span>if("1"===o[3]&amp;&amp;"0"===o[4]){let t=<span class="cstat-no" title="statement not covered" >"threshold",</span>e=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>e="1"===o[1]?"exceed":"fall";l</span>et i=<span class="cstat-no" title="statement not covered" >e+" "+t+" detected";<span class="cstat-no" title="statement not covered" ></span>a.push(i)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("0"===o[3]&amp;&amp;"1"===o[4]){let t=<span class="cstat-no" title="statement not covered" >"delta triggered";<span class="cstat-no" title="statement not covered" ></span>a.push(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>+=1}</span>}</span>function <span class="fstat-no" title="function not covered" >r(</span>t,a,e,i,l,d,r){let n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >t,</span>m=<span class="cstat-no" title="statement not covered" >0,</span>_=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;0===e;){let p=<span class="cstat-no" title="statement not covered" >i[d+3+t*n];<span class="cstat-no" title="statement not covered" ></span>if(void 0===p){<span class="cstat-no" title="statement not covered" >console.log(a),l.zclheader.alarmmess=a,e=1;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>t</span>!==u&amp;&amp;(t=u);l</span>et b=<span class="cstat-no" title="statement not covered" >s(p);<span class="cstat-no" title="statement not covered" ></span>if("1"===b[3]&amp;&amp;"0"===b[4]){<span class="cstat-no" title="statement not covered" >"1"===s(i[d+6+t*n])[0]&amp;&amp;(o=1,t+=2);l</span>et e=<span class="cstat-no" title="statement not covered" >"threshold",</span>l=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>"1"===b[1]?(l="exceed",m=s(i[d+7+t*n])+s(i[d+8+t*n]),m=parseInt(m,2),1===o&amp;&amp;(_=s(i[d+9+t*n])+s(i[d+10+t*n]),_=parseInt(_,2))):(l="fall",1===o?(m=s(i[d+7+t*n])+s(i[d+8+t*n]),m=parseInt(m,2),_=s(i[d+9+t*n])+s(i[d+10+t*n]),_=parseInt(_,2)):(_=s(i[d+7+t*n])+s(i[d+8+t*n]),_=parseInt(_,2)));l</span>et u=<span class="cstat-no" title="statement not covered" >e+" "+l+" detected: value: "+((256*i[d+4+t*n]+i[d+5+t*n])/r).toString()+" countUp: "+m+", countDown: "+_;<span class="cstat-no" title="statement not covered" ></span>a.push(u),1===o&amp;&amp;(t-=2,o=0)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("0"===b[3]&amp;&amp;"1"===b[4]){let e=<span class="cstat-no" title="statement not covered" >"delta triggered : "+((256*i[d+4+(t-=3)*n]+i[d+5+t*n])/r).toString();<span class="cstat-no" title="statement not covered" ></span>a.push(e)}<span class="cstat-no" title="statement not covered" ></span>n</span>+=1}</span>}</span>t.exports={normalisation_standard:function(t,n){let o="",u=t.bytes;console.log(t);let m=function(t,n){let o={lora:{}};o.lora.port=n;let u=t.length,m="";o.lora.payload="";for(let a=0;a&lt;u;a++){m=t[a].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.lora.payload+=m;let e=new Date;o.lora.date=e.toISOString()}<span class="missing-if-branch" title="else path not taken" >E</span>if(125===n)if(!1==!(1&amp;t[0])){o.zclheader={},o.zclheader.report="standard";let n=-1,u=-1,_=-1;if(o.zclheader.endpoint=(224&amp;t[0])&gt;&gt;5|(6&amp;t[0])&lt;&lt;2,u=t[1],o.zclheader.cmdID=l(u,2),_=256*t[2]+t[3],o.zclheader.clustID=l(_,4),10===u|138===u|1===u){o.data={},n=256*t[4]+t[5],o.zclheader.attID=l(n,4);let p=0;if(10!==u&amp;&amp;138!==u||(p=7),138===u&amp;&amp;(o.zclheader.alarm=1),1===u&amp;&amp;(p=8,o.zclheader.status=t[6]),1026===_&amp;&amp;0===n&amp;&amp;(o.data.temperature=a(256*t[p]+t[p+1],2)/100,138===u)){let a="",e=[],i=0,l=100;void 0===t[p+2]?(a="none",console.log("je suis dans le test undefined")):(<span class="branch-1 cbranch-no" title="branch not covered" >a=s(t[p+2]),console.log("je suis dans le test defined"))</span>,"none"===a&amp;&amp;(e.push("alarm triggered"),o.zclheader.alarmmess=e),"0"===a[2]&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >"1"===a[3]&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >d(1,e,i,t,o,p),</span>"1"===a[2]&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >"0"===a[3]&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >r(6,e,i,t,o,p,l)}</span>if(1029===_&amp;&amp;0===n){o.data.humidity=(256*t[p]+t[p+1])/100,void 0!==t[p+2]&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >s(t[p+2]);</span>let a=[],e=0,i=100,l="";void 0===t[p+2]?(l="none",console.log("je suis dans le test undefined")):(<span class="branch-1 cbranch-no" title="branch not covered" >l=s(t[p+2]),console.log("je suis dans le test defined"))</span>,"none"===l&amp;&amp;(a.push("alarm triggered"),o.zclheader.alarmmess=a),"0"===l[2]&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >"1"===l[3]&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >d(1,a,e,t,o,p),</span>"1"===l[2]&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >"0"===l[3]&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >r(6,a,e,t,o,p,i)}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(15===_&amp;&amp;1026===n&amp;&amp;(o.data.counter=256*t[p]*256*256+256*t[p+1]*256+256*t[p+2]+t[p+3]),15===_&amp;&amp;85===n&amp;&amp;(o.data.pin_state=!!t[p]),19===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >85===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.value=t[p])</span>,6===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n)</span>{let a=<span class="cstat-no" title="statement not covered" >t[p];<span class="cstat-no" title="statement not covered" ></span>o.data.state=1===a?"ON":"OFF"}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(32776===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.differential_pressure=256*t[p]+t[p+1])</span>,32773===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.pin_state_1=1==(1&amp;t[p+1]),o.data.pin_state_2=2==(2&amp;t[p+1]),o.data.pin_state_3=4==(4&amp;t[p+1]),o.data.pin_state_4=8==(8&amp;t[p+1]),o.data.pin_state_5=16==(16&amp;t[p+1]),o.data.pin_state_6=32==(32&amp;t[p+1]),o.data.pin_state_7=64==(64&amp;t[p+1]),o.data.pin_state_8=128==(128&amp;t[p+1]),o.data.pin_state_9=1==(1&amp;t[p]),o.data.pin_state_10=2==(2&amp;t[p]))</span>,12===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >85===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.analog=e(256*t[p]*256*256+256*t[p+1]*256+256*t[p+2]+t[p+3]))</span>,32775===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >1===n)</span>{<span class="cstat-no" title="statement not covered" >o.data.payload="",o.data.modbus_payload="",o.data.size=t[p],o.data.modbus_float=0;<span class="cstat-no" title="statement not covered" >f</span>or(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;o.data.size;a++)<span class="cstat-no" title="statement not covered" >m=t[p+a+1].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.payload+=m,0===a?o.data.modbus_address=t[p+a+1]:1===a?o.data.modbus_commandID=t[p+a+1]:2===a?o.data.modbus_size=t[p+a+1]:(o.data.modbus_payload+=m,1===o.data.modbus_float&amp;&amp;(3===a&amp;&amp;(o.data.fregister_00=e(256*t[p+a+1]*256*256+256*t[p+a+1+1]*256+256*t[p+a+1+2]+t[p+a+1+3])),7===a&amp;&amp;(o.data.fregister_01=e(256*t[p+a+1]*256*256+256*t[p+a+1+1]*256+256*t[p+a+1+2]+t[p+a+1+3])),11===a&amp;&amp;(o.data.fregister_02=e(256*t[p+a+1]*256*256+256*t[p+a+1+1]*256+256*t[p+a+1+2]+t[p+a+1+3])),15===a&amp;&amp;(o.data.fregister_03=e(256*t[p+a+1]*256*256+256*t[p+a+1+1]*256+256*t[p+a+1+2]+t[p+a+1+3])),19===a&amp;&amp;(o.data.fregister_04=e(256*t[p+a+1]*256*256+256*t[p+a+1+1]*256+256*t[p+a+1+2]+t[p+a+1+3])),23===a&amp;&amp;(o.data.fregister_05=e(256*t[p+a+1]*256*256+256*t[p+a+1+1]*256+256*t[p+a+1+2]+t[p+a+1+3])),27===a&amp;&amp;(o.data.fregister_06=e(256*t[p+a+1]*256*256+256*t[p+a+1+1]*256+256*t[p+a+1+2]+t[p+a+1+3])),31===a&amp;&amp;(o.data.fregister_07=e(256*t[p+a+1]*256*256+256*t[p+a+1+1]*256+256*t[p+a+1+2]+t[p+a+1+3])),35===a&amp;&amp;(o.data.fregister_08=e(256*t[p+a+1]*256*256+256*t[p+a+1+1]*256+256*t[p+a+1+2]+t[p+a+1+3])),35===a&amp;&amp;(o.data.fregister_09=e(256*t[p+a+1]*256*256+256*t[p+a+1+1]*256+256*t[p+a+1+2]+t[p+a+1+3]))),2===o.data.modbus_float&amp;&amp;(3===a&amp;&amp;(o.data.fregister_00=e(256*t[p+a+1]+t[p+a+1+1]+256*t[p+a+1+2]*256*256+256*t[p+a+1+3]*256)),7===a&amp;&amp;(o.data.fregister_01=e(256*t[p+a+1]+t[p+a+1+1]+256*t[p+a+1+2]*256*256+256*t[p+a+1+3]*256)),11===a&amp;&amp;(o.data.fregister_02=e(256*t[p+a+1]+t[p+a+1+1]+256*t[p+a+1+2]*256*256+256*t[p+a+1+3]*256)),15===a&amp;&amp;(o.data.fregister_03=e(256*t[p+a+1]+t[p+a+1+1]+256*t[p+a+1+2]*256*256+256*t[p+a+1+3]*256)),19===a&amp;&amp;(o.data.fregister_04=e(256*t[p+a+1]+t[p+a+1+1]+256*t[p+a+1+2]*256*256+256*t[p+a+1+3]*256)),23===a&amp;&amp;(o.data.fregister_05=e(256*t[p+a+1]+t[p+a+1+1]+256*t[p+a+1+2]*256*256+256*t[p+a+1+3]*256)),27===a&amp;&amp;(o.data.fregister_06=e(256*t[p+a+1]+t[p+a+1+1]+256*t[p+a+1+2]*256*256+256*t[p+a+1+3]*256)),31===a&amp;&amp;(o.data.fregister_07=e(256*t[p+a+1]+t[p+a+1+1]+256*t[p+a+1+2]*256*256+256*t[p+a+1+3]*256)),35===a&amp;&amp;(o.data.fregister_08=e(256*t[p+a+1]+t[p+a+1+1]+256*t[p+a+1+2]*256*256+256*t[p+a+1+3]*256)),35===a&amp;&amp;(o.data.fregister_09=e(256*t[p+a+1]+t[p+a+1+1]+256*t[p+a+1+2]*256*256+256*t[p+a+1+3]*256))))}<span class="missing-if-branch" title="if path not taken" >I</span></span></span>if(32777===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n)</span>{<span class="cstat-no" title="statement not covered" >if(o.data.payloads="",o.data.size=t[p],o.data.multimodbus_frame_series_sent=t[p+1],o.data.multimodbus_frame_number_in_serie=(224&amp;t[p+2])&gt;&gt;5,o.data.multimodbus_last_frame_of_serie=(28&amp;t[p+2])&gt;&gt;2,o.data.multimodbus_EP9=1==(1&amp;t[p+2]),o.data.multimodbus_EP8=2==(2&amp;t[p+2]),o.data.multimodbus_EP7=128==(128&amp;t[p+3]),o.data.multimodbus_EP6=64==(64&amp;t[p+3]),o.data.multimodbus_EP5=32==(32&amp;t[p+3]),o.data.multimodbus_EP4=16==(16&amp;t[p+3]),o.data.multimodbus_EP3=8==(8&amp;t[p+3]),o.data.multimodbus_EP2=4==(4&amp;t[p+3]),o.data.multimodbus_EP1=2==(2&amp;t[p+3]),o.data.multimodbus_EP0=1==(1&amp;t[p+3]),i2=p+4,without_header=0,!0===o.data.multimodbus_EP0){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP0_slaveID=t[i2],i2+=1,o.data.multimodbus_EP0_fnctID=t[i2],i2+=1,o.data.multimodbus_EP0_datasize=t[i2],i2+=1),o.data.multimodbus_EP0_payload="",void 0===t[i2])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;o.data.multimodbus_EP0_datasize;a++)<span class="cstat-no" title="statement not covered" >m=t[i2+a].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP0_payload+=m;<span class="cstat-no" title="statement not covered" >i</span></span>2+=o.data.multimodbus_EP0_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP1){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP1_slaveID=t[i2],i2+=1,o.data.multimodbus_EP1_fnctID=t[i2],i2+=1,o.data.multimodbus_EP1_datasize=t[i2],i2+=1),o.data.multimodbus_EP1_payload="",void 0===t[i2])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;o.data.multimodbus_EP1_datasize;a++)<span class="cstat-no" title="statement not covered" >m=t[i2+a].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP1_payload+=m;<span class="cstat-no" title="statement not covered" >i</span></span>2+=o.data.multimodbus_EP1_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP2){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP2_slaveID=t[i2],i2+=1,o.data.multimodbus_EP2_fnctID=t[i2],i2+=1,o.data.multimodbus_EP2_datasize=t[i2],i2+=1),o.data.multimodbus_EP2_payload="",void 0===t[i2])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;o.data.multimodbus_EP2_datasize;a++)<span class="cstat-no" title="statement not covered" >m=t[i2+a].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP2_payload+=m;<span class="cstat-no" title="statement not covered" >i</span></span>2+=o.data.multimodbus_EP2_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP3){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP3_slaveID=t[i2],i2+=1,o.data.multimodbus_EP3_fnctID=t[i2],i2+=1,o.data.multimodbus_EP3_datasize=t[i2],i2+=1),o.data.multimodbus_EP3_payload="",void 0===t[i2])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;o.data.multimodbus_EP3_datasize;a++)<span class="cstat-no" title="statement not covered" >m=t[i2+a].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP3_payload+=m;<span class="cstat-no" title="statement not covered" >i</span></span>2+=o.data.multimodbus_EP3_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP4){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP4_slaveID=t[i2],i2+=1,o.data.multimodbus_EP4_fnctID=t[i2],i2+=1,o.data.multimodbus_EP4_datasize=t[i2],i2+=1),o.data.multimodbus_EP4_payload="",void 0===t[i2])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;o.data.multimodbus_EP4_datasize;a++)<span class="cstat-no" title="statement not covered" >m=t[i2+a].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP4_payload+=m;<span class="cstat-no" title="statement not covered" >i</span></span>2+=o.data.multimodbus_EP4_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP5){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP5_slaveID=t[i2],i2+=1,o.data.multimodbus_EP5_fnctID=t[i2],i2+=1,o.data.multimodbus_EP5_datasize=t[i2],i2+=1),o.data.multimodbus_EP5_payload="",void 0===t[i2])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;o.data.multimodbus_EP5_datasize;a++)<span class="cstat-no" title="statement not covered" >m=t[i2+a].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP5_payload+=m;<span class="cstat-no" title="statement not covered" >i</span></span>2+=o.data.multimodbus_EP5_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP6){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP6_slaveID=t[i2],i2+=1,o.data.multimodbus_EP6_fnctID=t[i2],i2+=1,o.data.multimodbus_EP6_datasize=t[i2],i2+=1),o.data.multimodbus_EP6_payload="",void 0===t[i2])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;o.data.multimodbus_EP6_datasize;a++)<span class="cstat-no" title="statement not covered" >m=t[i2+a].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP6_payload+=m;<span class="cstat-no" title="statement not covered" >i</span></span>2+=o.data.multimodbus_EP6_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP7){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP7_slaveID=t[i2],i2+=1,o.data.multimodbus_EP7_fnctID=t[i2],i2+=1,o.data.multimodbus_EP7_datasize=t[i2],i2+=1),o.data.multimodbus_EP7_payload="",void 0===t[i2])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;o.data.multimodbus_EP7_datasize;a++)<span class="cstat-no" title="statement not covered" >m=t[i2+a].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP7_payload+=m;<span class="cstat-no" title="statement not covered" >i</span></span>2+=o.data.multimodbus_EP7_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP8){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP8_slaveID=t[i2],i2+=1,o.data.multimodbus_EP8_fnctID=t[i2],i2+=1,o.data.multimodbus_EP8_datasize=t[i2],i2+=1),o.data.multimodbus_EP8_payload="",void 0===t[i2])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;o.data.multimodbus_EP8_datasize;a++)<span class="cstat-no" title="statement not covered" >m=t[i2+a].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP8_payload+=m;<span class="cstat-no" title="statement not covered" >i</span></span>2+=o.data.multimodbus_EP8_datasize}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===o.data.multimodbus_EP9){<span class="cstat-no" title="statement not covered" >if(0===without_header&amp;&amp;(o.data.multimodbus_EP6_slaveID=t[i2],i2+=1,o.data.multimodbus_EP6_fnctID=t[i2],i2+=1,o.data.multimodbus_EP6_datasize=t[i2],i2+=1),o.data.multimodbus_EP6_payload="",void 0===t[i2])<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >f</span></span>or(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;o.data.multimodbus_EP6_datasize;a++)<span class="cstat-no" title="statement not covered" >m=t[i2+a].toString(16).toUpperCase(),1===m.length&amp;&amp;(m="0"+m),o.data.multimodbus_EP6_payload+=m;<span class="cstat-no" title="statement not covered" >i</span></span>2+=o.data.multimodbus_EP6_datasize}</span>}</span>if(82===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.active_energy_Wh=a(256*t[p+1]*256+256*t[p+2]+t[p+3],3),o.data.reactive_energy_Varh=a(256*t[p+4]*256+256*t[p+5]+t[p+6],3),o.data.nb_samples=256*t[p+7]+t[p+8],o.data.active_power_W=a(256*t[p+9]+t[p+10],2),o.data.reactive_power_let=a(256*t[p+11]+t[p+12],2))</span>,32772===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >1===t[p]&amp;&amp;(o.data.message_type="confirmed"),0===t[p]&amp;&amp;(o.data.message_type="unconfirmed"))</span>,32772===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >1===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.nb_retry=t[p])</span>,32772===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >2===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.period_in_minutes=256*t[p+1]+t[p+2],o.data.nb_err_frames=256*t[p+3]+t[p+4])</span>,80===_&amp;&amp;6===n){let a=p+3;1==(1&amp;t[p+2])&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o.data.main_or_external_voltage=(256*t[a]+t[a+1])/1e3,a+=2)</span>,2==(2&amp;t[p+2])&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o.data.rechargeable_battery_voltage=(256*t[a]+t[a+1])/1e3,a+=2)</span>,4==(4&amp;t[p+2])&amp;&amp;(o.data.disposable_battery_voltage=(256*t[a]+t[a+1])/1e3,a+=2),8==(8&amp;t[p+2])&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o.data.solar_harvesting_voltage=(256*t[a]+t[a+1])/1e3,a+=2)</span>,16==(16&amp;t[p+2])&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o.data.tic_harvesting_voltage=(256*t[a]+t[a+1])/1e3,a+=2)</span>}<span class="missing-if-branch" title="if path not taken" >I</span>if(32778===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n)</span>{let e=<span class="cstat-no" title="statement not covered" >p;<span class="cstat-no" title="statement not covered" ></span>o.data.sum_positive_active_energy_Wh=a(256*t[e+1]*256*256+256*t[e+2]*256+256*t[e+3]+t[e+4],4),e+=4,o.data.sum_negative_active_energy_Wh=a(256*t[e+1]*256*256+256*t[e+2]*256+256*t[e+3]+t[e+4],4),e+=4,o.data.sum_positive_reactive_energy_Wh=a(256*t[e+1]*256*256+256*t[e+2]*256+256*t[e+3]+t[e+4],4),e+=4,o.data.sum_negative_reactive_energy_Wh=a(256*t[e+1]*256*256+256*t[e+2]*256+256*t[e+3]+t[e+4],4),e+=4,o.data.positive_active_power_W=a(256*t[e+1]*256*256+256*t[e+2]*256+256*t[e+3]+t[e+4],4),e+=4,o.data.negative_active_power_W=a(256*t[e+1]*256*256+256*t[e+2]*256+256*t[e+3]+t[e+4],4),e+=4,o.data.positive_reactive_power_W=a(256*t[e+1]*256*256+256*t[e+2]*256+256*t[e+3]+t[e+4],4),e+=4,o.data.negative_reactive_power_W=a(256*t[e+1]*256*256+256*t[e+2]*256+256*t[e+3]+t[e+4],4)}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(32784===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n?</span>(<span class="branch-0 cbranch-no" title="branch not covered" >o.data.ActiveEnergyWhPhaseA=Int32UnsignedToSigned(256*t[p+1]*256*256+256*t[p+2]*256+256*t[p+3]+t[p+4]),o.data.ReactiveEnergyWhPhaseA=Int32UnsignedToSigned(256*t[p+5]*256*256+256*t[p+6]*256+256*t[p+7]+t[p+8]),o.data.ActiveEnergyWhPhaseB=Int32UnsignedToSigned(256*t[p+9]*256*256+256*t[p+10]*256+256*t[p+11]+t[p+12]),o.data.ReactiveEnergyWhPhaseB=Int32UnsignedToSigned(256*t[p+13]*256*256+256*t[p+14]*256+256*t[p+15]+t[p+16]),o.data.ActiveEnergyWhPhaseC=Int32UnsignedToSigned(256*t[p+17]*256*256+256*t[p+18]*256+256*t[p+19]+t[p+20]),o.data.ReactiveEnergyWhPhaseC=Int32UnsignedToSigned(256*t[p+21]*256*256+256*t[p+22]*256+256*t[p+23]+t[p+24]),o.data.ActiveEnergyWhPhaseABC=Int32UnsignedToSigned(256*t[p+25]*256*256+256*t[p+26]*256+256*t[p+27]+t[p+28]),o.data.ReactiveEnergyWhPhaseABC=Int32UnsignedToSigned(256*t[p+29]*256*256+256*t[p+30]*256+256*t[p+31]+t[p+32]))</span>:32784===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >1===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.ActivePowerWPhaseA=Int32UnsignedToSigned(256*t[p+1]*256*256+256*t[p+2]*256+256*t[p+3]+t[p+4]),o.data.ReactivePowerWPhaseA=Int32UnsignedToSigned(256*t[p+5]*256*256+256*t[p+6]*256+256*t[p+7]+t[p+8]),o.data.ActivePowerWPhaseB=Int32UnsignedToSigned(256*t[p+9]*256*256+256*t[p+10]*256+256*t[p+11]+t[p+12]),o.data.ReactivePowerWPhaseB=Int32UnsignedToSigned(256*t[p+13]*256*256+256*t[p+14]*256+256*t[p+15]+t[p+16]),o.data.ActivePowerWPhaseC=Int32UnsignedToSigned(256*t[p+17]*256*256+256*t[p+18]*256+256*t[p+19]+t[p+20]),o.data.ReactivePowerWPhaseC=Int32UnsignedToSigned(256*t[p+21]*256*256+256*t[p+22]*256+256*t[p+23]+t[p+24]),o.data.ActivePowerWPhaseABC=Int32UnsignedToSigned(256*t[p+25]*256*256+256*t[p+26]*256+256*t[p+27]+t[p+28]),o.data.ReactivePowerWPhaseABC=Int32UnsignedToSigned(256*t[p+29]*256*256+256*t[p+30]*256+256*t[p+31]+t[p+32]))</span>,32779===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n)</span>{let e=<span class="cstat-no" title="statement not covered" >p;<span class="cstat-no" title="statement not covered" ></span>o.data.Vrms=a(256*t[e+1]+t[e+2],2)/10,e+=2,o.data.Irms=a(256*t[e+1]+t[e+2],2)/10,e+=2,o.data.phase_angle=a(256*t[e+1]+t[e+2],2)}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(32781===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.VrmsA=a(256*t[p+1]+t[p+2],2)/10,o.data.IrmsA=a(256*t[p+3]+t[p+4],2)/10,o.data.PhaseA=a(256*t[p+5]+t[p+6],2),o.data.VrmsB=a(256*t[p+7]+t[p+8],2)/10,o.data.IrmsB=a(256*t[p+9]+t[p+10],2)/10,o.data.PhaseB=a(256*t[p+11]+t[p+12],2),o.data.VrmsC=a(256*t[p+13]+t[p+14],2)/10,o.data.IrmsC=a(256*t[p+15]+t[p+16],2)/10,o.data.PhaseC=a(256*t[p+17]+t[p+18],2))</span>,32780===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.Concentration=256*t[p]+t[p+1])</span>,1024===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.Illuminance=256*t[p]+t[p+1])</span>,1027===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.Pressure=a(256*t[p]+t[p+1],2))</span>,1030===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >o.data.Occupancy=!!t[p])</span>,32850===_&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >0===n)</span>{let e=<span class="cstat-no" title="statement not covered" >p;<span class="cstat-no" title="statement not covered" ></span>o.data.frequency=(a(256*t[e+1]+t[e+2],2)+22232)/1e3,e+=2,o.data.frequency_min=(a(256*t[e+1]+t[e+2],2)+22232)/1e3,e+=2,o.data.frequency_max=(a(256*t[e+1]+t[e+2],2)+22232)/1e3,e+=2,o.data.Vrms=a(256*t[e+1]+t[e+2],2)/10,e+=2,o.data.Vrms_min=a(256*t[e+1]+t[e+2],2)/10,e+=2,o.data.Vrms_max=a(256*t[e+1]+t[e+2],2)/10,e+=2,o.data.Vpeak=a(256*t[e+1]+t[e+2],2)/10,e+=2,o.data.Vpeak_min=a(256*t[e+1]+t[e+2],2)/10,e+=2,o.data.Vpeak_max=a(256*t[e+1]+t[e+2],2)/10,e+=2,o.data.over_voltage=a(256*t[e+1]+t[e+2],2),e+=2,o.data.sag_voltage=a(256*t[e+1]+t[e+2],2)}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(32783===_){let a=<span class="cstat-no" title="statement not covered" >p+1;<span class="cstat-no" title="statement not covered" ></span>if(0===n){let e=<span class="cstat-no" title="statement not covered" >o.data.Last={};<span class="cstat-no" title="statement not covered" ></span>e.NbTriggedAcq=i(t,a,"U32"),a+=4,e.Mean_X_G=i(t,a,"U16")/100,a+=2,e.Max_X_G=i(t,a,"U16")/100,a+=2,e.Dt_X_ms=i(t,a,"U16"),a+=2,e.Mean_Y_G=i(t,a,"U16")/100,a+=2,e.Max_Y_G=i(t,a,"U16")/100,a+=2,e.Dt_Y_ms=i(t,a,"U16"),a+=2,e.Mean_Z_G=i(t,a,"U16")/100,a+=2,e.Max_Z_G=i(t,a,"U16")/100,a+=2,e.Dt_Z_ms=i(t,a,"U16")}</span>else <span class="cstat-no" title="statement not covered" >if(1===n||2===n||3===n){let e=<span class="cstat-no" title="statement not covered" >1===n?"Stats_X":2===n?"Stats_Y":"Stats_Z",</span>l=<span class="cstat-no" title="statement not covered" >o.data[e]={};<span class="cstat-no" title="statement not covered" ></span>l.NbAcq=i(t,a,"U16"),a+=2,l.MinMean_G=i(t,a,"U16")/100,a+=2,l.MinMax_G=i(t,a,"U16")/100,a+=2,l.MinDt=i(t,a,"U16"),a+=2,l.MeanMean_G=i(t,a,"U16")/100,a+=2,l.MeanMax_G=i(t,a,"U16")/100,a+=2,l.MeanDt=i(t,a,"U16"),a+=2,l.MaxMean_G=i(t,a,"U16")/100,a+=2,l.MaxMax_G=i(t,a,"U16")/100,a+=2,l.MaxDt=i(t,a,"U16"),a+=2}</span>else <span class="cstat-no" title="statement not covered" >if(32768===n){let e=<span class="cstat-no" title="statement not covered" >o.data.Params={};<span class="cstat-no" title="statement not covered" ></span>e.WaitFreq_Hz=i(t,a,"U16")/10,a+=2,e.AcqFreq_Hz=i(t,a,"U16")/10,a+=2;l</span>et l=<span class="cstat-no" title="statement not covered" >i(t,a,"U16");<span class="cstat-no" title="statement not covered" ></span>a+=2,32768&amp;l&amp;&amp;(l=60*(-32769&amp;l)),e.NewWaitDelay_s=32768&amp;l?l=60*(-32769&amp;l):l,e.MaxAcqDuration_ms=i(t,a,"U16"),a+=2,e.Threshold_X_G=i(t,a,"U16")/100,a+=2,e.Threshold_Y_G=i(t,a,"U16")/100,a+=2,e.Threshold_Z_G=i(t,a,"U16")/100,a+=2,e.OverThrsh_Dt_ms=i(t,a,"U16"),a+=2,e.UnderThrsh_Dt_ms=i(t,a,"U16"),a+=2,e.Range_G=i(t,a,"U16")/100,a+=2,e.FilterSmoothCoef=i(t,a,"U8"),a+=1,e.FilterGainCoef=i(t,a,"U8"),a+=1,e=o.data.Params.WorkingModes={},e.SignalEachAcq=128&amp;t[a]?"true":"false",e.RstAftStdRpt_X=1&amp;t[a]?"true":"false",e.RstAftStdRpt_Y=2&amp;t[a]?"true":"false",e.RstAftStdRpt_7=4&amp;t[a]?"true":"false"}</span>}</span></span></span>}7===u&amp;&amp;(n=256*t[6]+t[7],o.zclheader.attID=l(n,4),o.zclheader.status=t[4],o.zclheader.batch=t[5]),9===u&amp;&amp;(n=256*t[6]+t[7],o.zclheader.attID=l(n,4),o.zclheader.status=t[4],o.zclheader.batch=t[5],o.zclheader.attribut_type=t[8],o.zclheader.min={},128==(128&amp;t[9])?(<span class="branch-0 cbranch-no" title="branch not covered" >o.zclheader.min.value=256*(t[9]-128)+t[10],o.zclheader.min.unity="minutes")</span>:(o.zclheader.min.value=256*t[9]+t[10],o.zclheader.min.unity="seconds"),o.zclheader.max={},128==(128&amp;t[11])?(<span class="branch-0 cbranch-no" title="branch not covered" >o.zclheader.max.value=256*(t[11]-128)+t[12],o.zclheader.max.unity="minutes")</span>:(o.zclheader.max.value=256*t[11]+t[12],o.zclheader.max.unity="seconds"),o.lora.payload="")}else o.batch={},o.batch.report="batch";return o}(u,t.fPort);if(console.log(m),void 0!==m.zclheader&amp;&amp;m.zclheader.alarm&amp;&amp;(o=m.zclheader.alarmmess,console.log(o)),7===u[1]&amp;&amp;u[0]%2!=0)return{data:{variable:"configure reporting response status",value:m.zclheader.status,date:t.recvTime},warning:o};if(9===u[1])return{data:{variable:"read reporting configuration response status",value:m.zclheader.status,date:t.recvTime},warning:o};if(1===u[1])return void 0===m.zclheader.data?{data:{variable:"read reporting configuration response status",value:"no data",date:t.recvTime},warning:o}:<span class="branch-1 cbranch-no" title="branch not covered" >{data:{variable:"read reporting configuration response status",value:m.zclheader.data,date:t.recvTime},warning:o};</span>if(void 0!==m.zclheader){<span class="missing-if-branch" title="if path not taken" >I</span>if(void 0!==n){let a=<span class="cstat-no" title="statement not covered" >m.zclheader.endpoint,</span>e=<span class="cstat-no" title="statement not covered" >Object.keys(m.data)[0];<span class="cstat-no" title="statement not covered" ></span>return{data:{variable:n[e][a],value:m.data[e],date:t.recvTime},type:"standard",warning:o}}</span>{let a=Object.keys(m.data)[0];return{data:{variable:a,value:m.data[a],date:t.recvTime},type:"standard",warning:o}}}return{type:m.batch.report,payload:m.lora.payload}}}}},a={};function e(i){var l=a[i];if(void 0!==l)return l.exports;var s=a[i]={exports:{}};return t[i](s,s.exports,e),s.exports}return e(263),e(971),e(684),e(421)})()));</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2023-08-02T08:28:19.469Z
            </div>
        <script src="prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="sorter.js"></script>
        <script src="block-navigation.js"></script>
    </body>
</html>
    